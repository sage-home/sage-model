#!/usr/bin/env python3
# generate_property_headers.py
# SAGE Property Header Generator
# This script reads properties.yaml and generates C header files containing
# macros and functions to access galaxy properties.

import os
import sys
import yaml
import re
from datetime import datetime

# Constants
HEADER_TEMPLATE = """/**
 * @file {header_filename}
 * @brief Auto-generated property definitions for SAGE model
 *
 * This file is automatically generated from properties.yaml by
 * generate_property_headers.py. DO NOT EDIT DIRECTLY.
 *
 * Generated on: {timestamp}
 */

#ifndef {include_guard}
#define {include_guard}

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

/* STEPS is defined in macros.h */

/* Property types and metadata */

/**
 * @brief Property ID enumeration used by core system
 */
typedef enum {{
{property_id_enum}
    PROP_COUNT  /* Total number of properties */
}} property_id_t;

/**
 * @brief Property metadata structure
 */
typedef struct {{
    const char *name;
    const char *type;
    const char *units;
    const char *description;
    bool output;
    int read_only;  /* 0=false, 1=true, 2=after_first_set */
    bool is_array;
    int array_dimension;
    const char *size_parameter;
}} property_meta_t;

/**
 * @brief Core galaxy property storage structure
 * This structure holds all the galaxy properties but is not
 * directly accessed. All access occurs through the generated macros.
 */
typedef struct {{
{property_struct_fields}
}} galaxy_properties_t;

/* Metadata array (accessible by property_id_t) */
extern property_meta_t PROPERTY_META[PROP_COUNT];

/* Forward declarations for property system */
struct GALAXY;
struct params;

/* Property system functions */

/**
 * @brief Initialize the property system
 * @param params Pointer to runtime parameters
 * @return 0 on success, non-zero on failure
 */
int initialize_property_system(const struct params *params);

/**
 * @brief Clean up the property system resources
 */
void cleanup_property_system(void);

/**
 * @brief Allocate property memory for a galaxy
 * @param g Galaxy pointer
 * @param params Pointer to runtime parameters
 * @return 0 on success, non-zero on failure
 */
int allocate_galaxy_properties(struct GALAXY *g, const struct params *params);

/**
 * @brief Free property memory for a galaxy
 * @param g Galaxy pointer
 */
void free_galaxy_properties(struct GALAXY *g);

/**
 * @brief Copy all properties from source galaxy to destination galaxy
 * @param dest Destination galaxy
 * @param src Source galaxy
 * @param params Pointer to runtime parameters
 * @return 0 on success, non-zero on failure
 */
int copy_galaxy_properties(struct GALAXY *dest, const struct GALAXY *src, const struct params *params);

/**
 * @brief Reset properties to initial values
 * @param g Galaxy pointer
 */
void reset_galaxy_properties(struct GALAXY *g);

/**
 * @brief Get property name string for a property ID
 * @param id Property ID
 * @return Property name string or NULL if ID is invalid
 */
const char* get_property_name(property_id_t id);

/**
 * @brief Get property ID for a property name
 * @param name Property name string
 * @return Property ID or PROP_COUNT if not found
 */
property_id_t get_property_id(const char *name);

/* Property accessors */
{property_accessor_macros}

#endif /* {include_guard} */
"""

IMPLEMENTATION_TEMPLATE = """/**
 * @file {impl_filename}
 * @brief Auto-generated property implementation for SAGE model
 *
 * This file is automatically generated from properties.yaml by
 * generate_property_headers.py. DO NOT EDIT DIRECTLY.
 *
 * Generated on: {timestamp}
 */

#include "core_allvars.h"
#include "core_properties.h"
#include "core_logging.h"
#include <string.h>
#include <stdlib.h>
#include <assert.h>

/* Property metadata array */
property_meta_t PROPERTY_META[PROP_COUNT] = {{
{property_meta_entries}
}};

/* Parameter resolution function for dynamic arrays */
{resolve_parameter_function}

/**
 * @brief Initialize the property system
 * @param params Pointer to runtime parameters
 * @return 0 on success, non-zero on failure
 */
int initialize_property_system(const struct params *params)
{{
    LOG_DEBUG("Initializing property system with %d properties", PROP_COUNT);
    /* Validate sizes of dynamic arrays from parameters */
{initialize_property_system_code}
    return 0;
}}

/**
 * @brief Clean up the property system resources
 */
void cleanup_property_system(void)
{{
    LOG_DEBUG("Cleaning up property system");
    /* Cleanup any allocated memory for the property system */
}}

/**
 * @brief Allocate property memory for a galaxy
 * @param g Galaxy pointer
 * @param params Pointer to runtime parameters
 * @return 0 on success, non-zero on failure
 */
int allocate_galaxy_properties(struct GALAXY *g, const struct params *params)
{{
    if (g == NULL) {{
        LOG_ERROR("Cannot allocate properties for NULL galaxy pointer");
        return -1;
    }}
    
    /* Allocate the property structure */
    g->properties = (galaxy_properties_t *)calloc(1, sizeof(galaxy_properties_t));
    if (g->properties == NULL) {{
        LOG_ERROR("Failed to allocate galaxy properties structure");
        return -1;
    }}
    
    /* Allocate memory for dynamic arrays */
{allocate_dynamic_arrays_code}
    
    return 0;
}}

/**
 * @brief Free property memory for a galaxy
 */
void free_galaxy_properties(struct GALAXY *g)
{{
    if (g == NULL || g->properties == NULL) {{
        return;
    }}
    
    /* Free dynamic arrays */
{free_dynamic_arrays_code}
    
    /* Free the property structure itself */
    free(g->properties);
    g->properties = NULL;
}}

/**
 * @brief Copy all properties from source galaxy to destination galaxy
 * @param dest Destination galaxy
 * @param src Source galaxy
 * @param params Pointer to runtime parameters
 * @return 0 on success, non-zero on failure
 */
int copy_galaxy_properties(struct GALAXY *dest, const struct GALAXY *src, const struct params *params)
{{
    if (dest == NULL || src == NULL) {{
        LOG_ERROR("NULL galaxy pointer in property copy");
        return -1;
    }}
    
    /* Free existing destination properties if present */
    free_galaxy_properties(dest);
    
    /* Allocate new properties */
    if (allocate_galaxy_properties(dest, params) != 0) {{
        return -1;
    }}
    
    /* Copy fixed-size fields */
{copy_fixed_fields_code}

    /* Copy dynamic arrays */
{copy_dynamic_arrays_code}
    
    return 0;
}}

/**
 * @brief Reset properties to initial values
 */
void reset_galaxy_properties(struct GALAXY *g)
{{
    if (g == NULL || g->properties == NULL) {{
        LOG_ERROR("Cannot reset properties for NULL galaxy or property pointer");
        return;
    }}
    
    /* Reset fixed properties to initial values */
{reset_property_values_code}
}}

/**
 * @brief Get property name string for a property ID
 */
const char* get_property_name(property_id_t id)
{{
    if (id >= 0 && id < PROP_COUNT) {{
        return PROPERTY_META[id].name;
    }}
    return NULL;
}}

/**
 * @brief Get property ID for a property name
 */
property_id_t get_property_id(const char *name)
{{
    if (name == NULL) {{
        return PROP_COUNT;
    }}
    
    for (int i = 0; i < PROP_COUNT; i++) {{
        if (strcmp(PROPERTY_META[i].name, name) == 0) {{
            return (property_id_t)i;
        }}
    }}
    
    return PROP_COUNT;
}}

/* Additional helper functions for property system */
{additional_helper_functions}
"""

# C type mapping
C_TYPE_MAP = {
    "int": "int",
    "int32_t": "int32_t",
    "uint32_t": "uint32_t",
    "int64_t": "int64_t",
    "uint64_t": "uint64_t",
    "long long": "long long",
    "float": "float",
    "double": "double",
    "bool": "bool",
    "char": "char",
}

def sanitize_include_guard(filename):
    """Convert a filename to a valid C include guard name"""
    base = os.path.basename(filename)
    base = os.path.splitext(base)[0].upper()
    return f"{base}_H"

def parse_type(type_str):
    """Parse a type string and determine base type, array dimensions, and if it's dynamic"""
    is_array = False
    array_dim = 0
    is_dynamic = False
    base_type = type_str
    size_spec = ""
    
    # Check for array syntax: type[size] or type[]
    array_match = re.match(r'(\w+)(?:\[(\w*)\])+', type_str)
    if array_match:
        is_array = True
        base_type = array_match.group(1)
        size_spec = array_match.group(2)
        
        if size_spec == "":
            # Dynamic array: type[]
            is_dynamic = True
        else:
            # Fixed array: type[SIZE]
            array_dim = size_spec
    
    return base_type, is_array, array_dim, is_dynamic, size_spec

def generate_property_id_enum(properties):
    """Generate property ID enumeration from properties list"""
    enum_lines = []
    for prop in properties:
        enum_lines.append(f"    PROP_{prop['name']},")
    return "\n".join(enum_lines)

def generate_property_struct_fields(properties):
    """Generate struct fields for the galaxy_properties_t structure"""
    fields = []
    
    for prop in properties:
        # Get type information
        type_str = prop['type']
        base_type, is_array, array_dim, is_dynamic, size_spec = parse_type(type_str)
        
        # Generate field declarations
        if is_array:
            if is_dynamic:
                # Dynamic array with size field
                fields.append(f"    {base_type} *{prop['name']};")
                fields.append(f"    int {prop['name']}_size;")
            else:
                # Fixed-size array
                fields.append(f"    {base_type} {prop['name']}[{array_dim}];")
        else:
            # Simple scalar field
            fields.append(f"    {base_type} {prop['name']};")
    
    return "\n".join(fields)

def generate_property_accessor_macros(properties):
    """Generate accessor macros for all properties"""
    macros = []
    
    # Add the safe array access macro at the beginning
    macros.append("""/**
 * @brief Safely access an element of a galaxy property array with bounds checking.
 * @param g Pointer to the GALAXY struct.
 * @param prop_base_name The base name of the property (e.g., StarFormationHistory).
 * @param idx The index to access.
 * @param default_val The value to return if the index is out of bounds.
 * @return The array element value or default_val on error.
 */
#define GALAXY_PROP_ARRAY_SAFE(g, prop_base_name, idx, default_val) \\
    (((idx) >= 0 && (idx) < (g)->properties->prop_base_name##_size) ? \\
     ((g)->properties->prop_base_name[idx]) : \\
     (LOG_ERROR("Array index out of bounds: %s[%d] (size: %d)", #prop_base_name, (idx), (g)->properties->prop_base_name##_size), (default_val)))
""")
    
    for prop in properties:
        # Get type information
        type_str = prop['type']
        base_type, is_array, array_dim, is_dynamic, size_spec = parse_type(type_str)
        
        read_only = prop.get('read_only', False)
        read_only_comment = ""
        if read_only and read_only != "false":
            read_only_comment = " /* Read-only" + (" after first set" if read_only == "after_first_set" else "") + " */"
            
        # Generate accessor macro
        macros.append(f"#define GALAXY_PROP_{prop['name']}(g) ((g)->properties->{prop['name']}){read_only_comment}")
        
        # Add element accessor for arrays
        if is_array:
            if is_dynamic:
                # Add size accessor for dynamic arrays
                macros.append(f"#define GALAXY_PROP_{prop['name']}_SIZE(g) ((g)->properties->{prop['name']}_size)")
            
            # Element accessor works for both fixed and dynamic arrays
            macros.append(f"#define GALAXY_PROP_{prop['name']}_ELEM(g, idx) ((g)->properties->{prop['name']}[idx])")
            
            # For dynamic arrays, add a size setter function declaration
            if is_dynamic:
                macros.append(f"\nint galaxy_set_{prop['name']}_size(struct GALAXY *g, int size);")
                
        macros.append("")  # Add blank line between property accessors
    
    return "\n".join(macros)

def generate_property_meta_entries(properties):
    """Generate property metadata array entries"""
    meta_entries = []
    
    for i, prop in enumerate(properties):
        # Get type information
        type_str = prop['type']
        base_type, is_array, array_dim, is_dynamic, size_spec = parse_type(type_str)
        
        # Convert read_only to int value (0=false, 1=true, 2=after_first_set)
        read_only = prop.get('read_only', False)
        read_only_val = 0
        if read_only == True or read_only == "true":
            read_only_val = 1
        elif read_only == "after_first_set":
            read_only_val = 2
            
        # Size parameter for dynamic arrays
        size_param = "NULL"
        if is_dynamic and 'size_parameter' in prop:
            size_param = f'"{prop["size_parameter"]}"'
        
        # Format the entry
        entry = f"""    /* PROP_{prop['name']} */
    {{
        "{prop['name']}",
        "{type_str}",
        "{prop.get('units', 'dimensionless')}",
        "{prop.get('description', '')}",
        {str(prop.get('output', True)).lower()},
        {read_only_val},
        {str(is_array).lower()},
        {array_dim if array_dim else 0},
        {size_param}
    }}"""
        
        # Add comma if not the last entry
        if i < len(properties) - 1:
            entry += ","
            
        meta_entries.append(entry)
    
    return "\n".join(meta_entries)

def generate_initialize_code(properties):
    """Generate code for initializing the property system"""
    code_lines = []
    
    code_lines.append("    if (params == NULL) {")
    code_lines.append("        LOG_ERROR(\"Params pointer is NULL during property system initialization.\");")
    code_lines.append("        return -1;")
    code_lines.append("    }")
    code_lines.append("    LOG_DEBUG(\"Validating dynamic array size parameters...\");")
    code_lines.append("    for (int i = 0; i < PROP_COUNT; i++) {")
    code_lines.append("        if (PROPERTY_META[i].is_array && PROPERTY_META[i].array_dimension == 0 &&")
    code_lines.append("            PROPERTY_META[i].size_parameter != NULL) {")
    code_lines.append("            int size = resolve_parameter_value(PROPERTY_META[i].size_parameter, params);")
    code_lines.append("            if (size < 0) {") # Check for negative size (error from resolve)
    code_lines.append("                LOG_ERROR(\"Failed to resolve or invalid size parameter '%s' for dynamic array '%s'\",")
    code_lines.append("                         PROPERTY_META[i].size_parameter, PROPERTY_META[i].name);")
    code_lines.append("                return -1; // Fail initialization")
    code_lines.append("            }")
    code_lines.append("            LOG_DEBUG(\"Validated size parameter '%s' for dynamic array '%s' (resolved size: %d)\",")
    code_lines.append("                       PROPERTY_META[i].size_parameter, PROPERTY_META[i].name, size);")
    code_lines.append("        }")
    code_lines.append("    }")
    
    return "\n".join(code_lines)

def generate_allocate_arrays_code(properties):
    """Generate code for allocating dynamic arrays"""
    code_lines = []
    
    # Find properties with dynamic arrays
    dynamic_arrays = [p for p in properties if parse_type(p['type'])[3]]
    if dynamic_arrays:
        for prop in dynamic_arrays:
            base_type = parse_type(prop['type'])[0]
            code_lines.extend([
                f"    /* Allocate {prop['name']} array */",
                f"    if (PROPERTY_META[PROP_{prop['name']}].size_parameter != NULL) {{",
                f"        // Get size from parameters",
                f"        int resolved_size = resolve_parameter_value(PROPERTY_META[PROP_{prop['name']}].size_parameter, params);",
                f"        if (resolved_size < 0) {{",
                f"            LOG_ERROR(\"Failed to resolve size for dynamic array '{prop['name']}' during allocation\");",
                f"            free_galaxy_properties(g); // Cleanup partially allocated",
                f"            return -1;",
                f"        }}",
                f"        // Call the specific generated size setter",
                f"        int status = galaxy_set_{prop['name']}_size(g, resolved_size);",
                f"        if (status != 0) {{",
                f"            LOG_ERROR(\"Failed to set size and allocate for dynamic array '{prop['name']}'\");",
                f"            free_galaxy_properties(g); // Cleanup partially allocated",
                f"            return -1;",
                f"        }}",
                f"        LOG_DEBUG(\"Allocated dynamic array '{prop['name']}' with size %d\", resolved_size);",
                f"    }}"
            ])
    
    return "\n".join(code_lines)

def generate_free_arrays_code(properties):
    """Generate code for freeing dynamic arrays"""
    code_lines = []
    
    # Find properties with dynamic arrays
    dynamic_arrays = [p for p in properties if parse_type(p['type'])[3]]
    if dynamic_arrays:
        for prop in dynamic_arrays:
            code_lines.extend([
                f"    /* Free {prop['name']} array */",
                f"    if (g->properties->{prop['name']} != NULL) {{",
                f"        free(g->properties->{prop['name']});",
                f"        g->properties->{prop['name']} = NULL;",
                f"        g->properties->{prop['name']}_size = 0;",
                f"    }}"
            ])
    
    return "\n".join(code_lines)

def generate_copy_fixed_fields_code(properties):
    """Generate code for copying fixed-size fields"""
    return """    /* Copy the basic structure */
    memcpy(dest->properties, src->properties, sizeof(galaxy_properties_t));

    /* Reset dynamic array pointers to NULL to avoid double-free issues */""" + '\n'.join([
        f"    dest->properties->{p['name']} = NULL;" 
        for p in properties if parse_type(p['type'])[3]
    ])

def generate_copy_dynamic_arrays_code(properties):
    """Generate code for copying dynamic arrays"""
    code_lines = []
    
    # Find properties with dynamic arrays
    dynamic_arrays = [p for p in properties if parse_type(p['type'])[3]]
    if dynamic_arrays:
        for prop in dynamic_arrays:
            base_type = parse_type(prop['type'])[0]
            code_lines.extend([
                f"    /* Copy {prop['name']} array */",
                f"    if (src->properties->{prop['name']} != NULL && src->properties->{prop['name']}_size > 0) {{",
                f"        int size = src->properties->{prop['name']}_size;",
                f"        dest->properties->{prop['name']} = ({base_type} *)malloc(size * sizeof({base_type}));",
                f"        if (dest->properties->{prop['name']} == NULL) {{",
                f"            LOG_ERROR(\"Failed to allocate memory for {prop['name']} property during copy\");",
                f"            return -1;",
                f"        }}",
                f"        dest->properties->{prop['name']}_size = size;",
                f"        memcpy(dest->properties->{prop['name']}, src->properties->{prop['name']}, size * sizeof({base_type}));",
                f"    }}",
            ])
    
    return "\n".join(code_lines)

def generate_reset_property_values_code(properties):
    """Generate code for resetting properties to initial values"""
    code_lines = []
    
    # Reset all properties to their initial values
    for prop in properties:
        type_str = prop['type']
        base_type, is_array, array_dim, is_dynamic, size_spec = parse_type(type_str)
        initial_value = prop.get('initial_value', 0)
        
        if is_array:
            if is_dynamic:
                # Dynamic arrays - don't reset, just leave as is
                continue
            
            if isinstance(initial_value, list):
                # List of initial values for array elements
                for i, val in enumerate(initial_value):
                    if i < int(array_dim):  # Only set values that fit in the array
                        code_lines.append(f"    g->properties->{prop['name']}[{i}] = {val}f;")
            else:
                # Single initial value for all elements
                code_lines.append(f"    for (int i = 0; i < {array_dim}; i++) {{")
                code_lines.append(f"        g->properties->{prop['name']}[i] = {initial_value}f;")
                code_lines.append(f"    }}")
        else:
            # Simple scalar field
            suffix = ""
            if base_type == "float":
                suffix = "f"
            elif base_type == "double":
                suffix = ""  # No suffix for double
                
            code_lines.append(f"    g->properties->{prop['name']} = {initial_value}{suffix};")
    
    return "\n".join(code_lines)

def generate_helper_functions(properties):
    """Generate additional helper functions for the property system"""
    functions = []
    
    # Add size setter functions for dynamic arrays
    dynamic_arrays = [p for p in properties if parse_type(p['type'])[3]]
    for prop in dynamic_arrays:
        base_type = parse_type(prop['type'])[0]
        
        # Start with standard function header and validation
        func_lines = [
            f"/**",
            f" * @brief Set the size of the {prop['name']} dynamic array",
            f" * @param g Galaxy pointer",
            f" * @param size New size for the array",
            f" * @return 0 on success, non-zero on failure",
            f" */",
            f"int galaxy_set_{prop['name']}_size(struct GALAXY *g, int size)",
            "{",
            f"    if (g == NULL || g->properties == NULL) {{",
            f"        LOG_ERROR(\"Cannot set size for NULL galaxy or property pointer\");",
            f"        return -1;",
            f"    }}",
            f"    ",
            f"    if (size < 0) {{",
            f"        LOG_ERROR(\"Cannot set negative size for {prop['name']} array\");",
            f"        return -1;",
            f"    }}",
            f"    ",
            f"    /* Free existing array if present */",
            f"    if (g->properties->{prop['name']} != NULL) {{",
            f"        free(g->properties->{prop['name']});",
            f"        g->properties->{prop['name']} = NULL;",
            f"    }}",
            f"    ",
            f"    /* Set new size */",
            f"    g->properties->{prop['name']}_size = size;",
            f"    ",
            f"    /* Allocate new array if size > 0 */",
            f"    if (size > 0) {{",
            f"        g->properties->{prop['name']} = ({base_type} *)calloc(size, sizeof({base_type}));",
            f"        if (g->properties->{prop['name']} == NULL) {{",
            f"            LOG_ERROR(\"Failed to allocate memory for {prop['name']} array\");",
            f"            g->properties->{prop['name']}_size = 0;",
            f"            return -1;",
            f"        }}"
        ]
        
        # Check for non-zero initial value
        initial_value = prop.get('initial_value')
        if initial_value is not None and str(initial_value) != '0' and str(initial_value) != '0.0':
            func_lines.extend([
                f"        ",
                f"        /* Initialize array with non-zero value {initial_value} */",
                f"        for (int i = 0; i < size; i++) {{",
                f"            g->properties->{prop['name']}[i] = {initial_value};",
                f"        }}"
            ])
        
        # Add function closing
        func_lines.extend([
            f"    }}",
            f"    ",
            f"    return 0;",
            "}"
        ])
        
        # Add function lines to the overall functions list
        functions.extend(func_lines)
    
    return "\n".join(functions)

def generate_resolve_parameter_function():
    """Generate the resolve_parameter_value function"""
    return '''
/**
 * @brief Resolve a parameter name to its integer value
 * @param param_name Name of the parameter (e.g., "simulation.NumSnapOutputs")
 * @param params Pointer to the runtime parameters structure
 * @return Parameter value, or -1 on error
 */
static int resolve_parameter_value(const char *param_name, const struct params *params) {
    if (param_name == NULL || params == NULL) {
        LOG_ERROR("NULL parameter name or params pointer in resolve_parameter_value");
        return -1;
    }
    
    // Add specific parameter lookups here
    if (strcmp(param_name, "simulation.NumSnapOutputs") == 0) {
        // Ensure NumSnapOutputs is valid before returning
        if (params->simulation.NumSnapOutputs <= 0) {
            LOG_ERROR("Invalid value for simulation.NumSnapOutputs: %d", params->simulation.NumSnapOutputs);
            return -1;
        }
        return params->simulation.NumSnapOutputs;
    }
    // Add lookups for other potential size parameters here...
    // Example:
    // else if (strcmp(param_name, "some_other_section.some_size") == 0) {
    //     return params->some_other_section.some_size;
    // }

    LOG_ERROR("Unknown parameter name for dynamic array size: %s", param_name);
    return -1;
}
'''

def generate_header_file(properties, output_dir=""):
    """Generate the property header file"""
    header_filename = "core_properties.h"
    output_path = os.path.join(output_dir, header_filename)
    
    # Generate header components
    include_guard = sanitize_include_guard(header_filename)
    property_id_enum = generate_property_id_enum(properties)
    property_struct_fields = generate_property_struct_fields(properties)
    property_accessor_macros = generate_property_accessor_macros(properties)
    
    # Fill in the template
    header_content = HEADER_TEMPLATE.format(
        header_filename=header_filename,
        include_guard=include_guard,
        timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        property_id_enum=property_id_enum,
        property_struct_fields=property_struct_fields,
        property_accessor_macros=property_accessor_macros
    )
    
    # Write the header file
    with open(output_path, "w") as f:
        f.write(header_content)
    
    print(f"Generated {output_path}")

def generate_implementation_file(properties, output_dir=""):
    """Generate the property implementation file"""
    impl_filename = "core_properties.c"
    header_filename = "core_properties.h"
    output_path = os.path.join(output_dir, impl_filename)
    
    # Generate implementation components
    property_meta_entries = generate_property_meta_entries(properties)
    initialize_property_system_code = generate_initialize_code(properties)
    allocate_dynamic_arrays_code = generate_allocate_arrays_code(properties)
    free_dynamic_arrays_code = generate_free_arrays_code(properties)
    copy_fixed_fields_code = generate_copy_fixed_fields_code(properties)
    copy_dynamic_arrays_code = generate_copy_dynamic_arrays_code(properties)
    reset_property_values_code = generate_reset_property_values_code(properties)
    additional_helper_functions = generate_helper_functions(properties)
    resolve_parameter_function = generate_resolve_parameter_function()
    
    # Fill in the template
    impl_content = IMPLEMENTATION_TEMPLATE.format(
        impl_filename=impl_filename,
        header_filename=header_filename,
        timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        property_meta_entries=property_meta_entries,
        initialize_property_system_code=initialize_property_system_code,
        allocate_dynamic_arrays_code=allocate_dynamic_arrays_code,
        free_dynamic_arrays_code=free_dynamic_arrays_code,
        copy_fixed_fields_code=copy_fixed_fields_code,
        copy_dynamic_arrays_code=copy_dynamic_arrays_code,
        reset_property_values_code=reset_property_values_code,
        additional_helper_functions=additional_helper_functions,
        resolve_parameter_function=resolve_parameter_function
    )
    
    # Write the implementation file
    with open(output_path, "w") as f:
        f.write(impl_content)
    
    print(f"Generated {output_path}")

def load_fetch_numoutputs_placeholder():
    """Create a placeholder function to fetch NumSnapOutputs for dynamic arrays"""
    code = """
/**
 * @brief Fetch NumSnapOutputs parameter for sizing dynamic arrays
 * This is a temporary placeholder for the full parameter system integration
 * @return Number of snapshot outputs or a default value
 */
int fetch_NumSnapOutputs(void) {
    extern struct params Params;  /* From core_allvars.h */
    return Params.simulation.NumSnapOutputs;
}
"""
    return code

def main():
    """Main entry point for the script"""
    # Determine file paths
    script_dir = os.path.dirname(os.path.abspath(__file__))
    yaml_file = os.path.join(script_dir, "properties.yaml")
    core_dir = os.path.join(script_dir, "core")
    
    # Check if properties.yaml exists
    if not os.path.exists(yaml_file):
        print(f"Error: Could not find properties.yaml at {yaml_file}")
        sys.exit(1)
    
    try:
        # Load properties from YAML
        with open(yaml_file, "r") as f:
            data = yaml.safe_load(f)
            properties = data.get("properties", [])
        
        if not properties:
            print("Error: No properties found in properties.yaml")
            sys.exit(1)
        
        # Generate the header and implementation files
        generate_header_file(properties, core_dir)
        generate_implementation_file(properties, core_dir)
        
        print("Property header generation complete!")
        
    except Exception as e:
        print(f"Error generating property headers: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()
