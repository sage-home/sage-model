#!/usr/bin/env python3
# generate_property_headers.py
# SAGE Property and Parameter Header Generator
# This script reads properties.yaml and parameters.yaml and generates C header files containing
# macros and functions to access galaxy properties and runtime parameters, as well as output transformer
# dispatch code.
#
# Module-aware property generation:
# - Only generates properties needed by active modules
# - Core properties (is_core: true) always included
# - Physics properties only included if their modules are active
#
# Parameter system generation:
# - Generates parameter accessors, metadata, and validation
# - Supports core and physics parameters with type safety
# - Auto-generates parameter file reading infrastructure

import os
import sys
import yaml
import re
from datetime import datetime

# Constants
HEADER_TEMPLATE = """/**
 * @file {header_filename}
 * @brief Auto-generated property definitions for SAGE model
 *
 * This file is automatically generated from properties.yaml by
 * generate_property_headers.py. DO NOT EDIT DIRECTLY.
 *
 * Generated on: {timestamp}
 */

#ifndef {include_guard}
#define {include_guard}

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "macros.h" /* For STEPS definition */

/* HDF5 types needed for property transformer function signatures */
#ifdef HDF5
#include <hdf5.h>
#else
/* Minimal HDF5 type definitions when HDF5 is not available */
typedef int hid_t;
#define H5T_NATIVE_FLOAT 0
#define H5T_NATIVE_DOUBLE 1
#define H5T_NATIVE_INT 2
#define H5T_NATIVE_LLONG 3
#define H5T_NATIVE_ULLONG 4
#endif

/* Property types and metadata */

/**
 * @brief Property ID enumeration used by core system
 */
typedef enum {{
{property_id_enum}
    PROP_COUNT  /* Total number of properties */
}} property_id_t;

/* STEPS is already defined in macros.h - using that value for array dimensions */

/**
 * @brief Property metadata structure
 */
typedef struct {{
    const char *name;
    const char *type;
    const char *units;
    const char *description;
    bool output;
    int read_only;  /* 0=false, 1=true, 2=after_first_set */
    bool is_array;
    int array_dimension;
    const char *size_parameter;
}} property_meta_t;

/**
 * @brief Core galaxy property storage structure
 * This structure holds all the galaxy properties but is not
 * directly accessed. All access occurs through the generated macros.
 */
typedef struct {{
{property_struct_fields}
}} galaxy_properties_t;

/* Metadata array (accessible by property_id_t) */
extern property_meta_t PROPERTY_META[PROP_COUNT];

/* Forward declarations for property system */
struct GALAXY;
struct params;

/* Property system functions */

/**
 * @brief Initialize the property system
 * @param params Pointer to runtime parameters
 * @return 0 on success, non-zero on failure
 */
int initialize_property_system(const struct params *params);

/**
 * @brief Clean up the property system resources
 */
void cleanup_property_system(void);

/**
 * @brief Allocate property memory for a galaxy
 * @param g Galaxy pointer
 * @param params Pointer to runtime parameters
 * @return 0 on success, non-zero on failure
 */
int allocate_galaxy_properties(struct GALAXY *g, const struct params *params);

/**
 * @brief Free property memory for a galaxy
 * @param g Galaxy pointer
 */
void free_galaxy_properties(struct GALAXY *g);

/**
 * @brief Copy all properties from source galaxy to destination galaxy
 * @param dest Destination galaxy
 * @param src Source galaxy
 * @param params Pointer to runtime parameters
 * @return 0 on success, non-zero on failure
 */
int copy_galaxy_properties(struct GALAXY *dest, const struct GALAXY *src, const struct params *params);

/**
 * @brief Reset properties to initial values
 * @param g Galaxy pointer
 */
void reset_galaxy_properties(struct GALAXY *g);

/**
 * @brief Get property name string for a property ID
 * @param id Property ID
 * @return Property name string or NULL if ID is invalid
 */
const char* get_property_name(property_id_t id);

/**
 * @brief Get property ID for a property name
 * @param name Property name string
 * @return Property ID or PROP_COUNT if not found
 */
property_id_t get_property_id(const char *name);

/* Generated property dispatcher functions */
float get_generated_float(const galaxy_properties_t *props, property_id_t prop_id, float default_value);
int32_t get_generated_int32(const galaxy_properties_t *props, property_id_t prop_id, int32_t default_value);
double get_generated_double(const galaxy_properties_t *props, property_id_t prop_id, double default_value);

float get_generated_float_array_element(const galaxy_properties_t *props, property_id_t prop_id, int array_idx, float default_value);
int32_t get_generated_int32_array_element(const galaxy_properties_t *props, property_id_t prop_id, int array_idx, int32_t default_value);
double get_generated_double_array_element(const galaxy_properties_t *props, property_id_t prop_id, int array_idx, double default_value);

int get_generated_array_size(const galaxy_properties_t *props, property_id_t prop_id);

/* Generated property dispatcher functions - setters */
void set_generated_float(galaxy_properties_t *props, property_id_t prop_id, float value);
void set_generated_int32(galaxy_properties_t *props, property_id_t prop_id, int32_t value);
void set_generated_double(galaxy_properties_t *props, property_id_t prop_id, double value);
void set_generated_float_array_element(galaxy_properties_t *props, property_id_t prop_id, int array_idx, float value);

/* Output transformer dispatch function */
/**
 * @brief Dispatches to the appropriate output transformer or performs default identity transform.
 * @param galaxy The galaxy being processed.
 * @param output_prop_id Property ID of the field being written to HDF5.
 * @param output_prop_name Name of the field being written to HDF5.
 * @param output_buffer_element_ptr Pointer to the HDF5 buffer slot for this galaxy's property.
 * @param run_params Global run parameters.
 * @param h5_dtype HDF5 data type of the output field.
 * @return 0 on success, non-zero on error.
 */
int dispatch_property_transformer(const struct GALAXY *galaxy,
                                  property_id_t output_prop_id,
                                  const char *output_prop_name,
                                  void *output_buffer_element_ptr,
                                  const struct params *run_params,
                                  hid_t h5_dtype);

/* Property accessors */
{property_accessor_macros}

#endif /* {include_guard} */
"""

TRANSFORMERS_TEMPLATE = """/**
 * @file {transformers_filename}
 * @brief Auto-generated output transformer dispatch for SAGE model
 *
 * This file is automatically generated from properties.yaml by
 * generate_property_headers.py. DO NOT EDIT DIRECTLY.
 *
 * Generated on: {timestamp}
 */

#include "core_allvars.h"
#include "core_properties.h"
#include "core_property_utils.h"
#include "core_logging.h"
#include <string.h>

/* Extern declarations for all transformer functions */
{transformer_function_externs}

/**
 * @brief Dispatches to the appropriate output transformer or performs default identity transform.
 * @param galaxy The galaxy being processed.
 * @param output_prop_id Property ID of the field being written to HDF5.
 * @param output_prop_name Name of the field being written to HDF5.
 * @param output_buffer_element_ptr Pointer to the HDF5 buffer slot for this galaxy's property.
 * @param run_params Global run parameters.
 * @param h5_dtype HDF5 data type of the output field.
 * @return 0 on success, non-zero on error.
 */
int dispatch_property_transformer(const struct GALAXY *galaxy,
                                  property_id_t output_prop_id,
                                  const char *output_prop_name,
                                  void *output_buffer_element_ptr,
                                  const struct params *run_params,
                                  hid_t h5_dtype) {{
    int status = 0;
    
    // Auto-generated if/else if chain based on property name
{dispatcher_if_chain}
    
    return status;
}}
"""

IMPLEMENTATION_TEMPLATE = """/**
 * @file {impl_filename}
 * @brief Auto-generated property implementation for SAGE model
 *
 * This file is automatically generated from properties.yaml by
 * generate_property_headers.py. DO NOT EDIT DIRECTLY.
 *
 * Generated on: {timestamp}
 */

#include "core_allvars.h"
#include "core_properties.h"
#include "core_logging.h"
#include "core_pipeline_system.h"
#include "core_config_system.h"
#include <string.h>
#include <stdlib.h>
#include <assert.h>

/* Property metadata array */
property_meta_t PROPERTY_META[PROP_COUNT] = {{
{property_meta_entries}
}};

/* Parameter resolution function for dynamic arrays */
{resolve_parameter_function}

/**
 * @brief Initialize the property system
 * @param params Pointer to runtime parameters
 * @return 0 on success, non-zero on failure
 */
int initialize_property_system(const struct params *params)
{{
    LOG_DEBUG("Initializing property system with %d properties", PROP_COUNT);
    /* Validate sizes of dynamic arrays from parameters */
{initialize_property_system_code}
    return 0;
}}

/**
 * @brief Clean up the property system resources
 */
void cleanup_property_system(void)
{{
    LOG_DEBUG("Cleaning up property system");
    /* Cleanup any allocated memory for the property system */
}}

/**
 * @brief Allocate property memory for a galaxy
 * @param g Galaxy pointer
 * @param params Pointer to runtime parameters
 * @return 0 on success, non-zero on failure
 */
int allocate_galaxy_properties(struct GALAXY *g, const struct params *params)
{{
    if (g == NULL) {{
        LOG_ERROR("Cannot allocate properties for NULL galaxy pointer");
        return -1;
    }}
    
    /* Allocate the property structure */
    g->properties = (galaxy_properties_t *)calloc(1, sizeof(galaxy_properties_t));
    if (g->properties == NULL) {{
        LOG_ERROR("Failed to allocate galaxy properties structure");
        return -1;
    }}
    
    /* Allocate memory for dynamic arrays */
{allocate_dynamic_arrays_code}
    
    return 0;
}}

/**
 * @brief Free property memory for a galaxy
 */
void free_galaxy_properties(struct GALAXY *g)
{{
    if (g == NULL || g->properties == NULL) {{
        return;
    }}
    
    /* Free dynamic arrays */
{free_dynamic_arrays_code}
    
    /* Free the property structure itself */
    free(g->properties);
    g->properties = NULL;
}}

/**
 * @brief Copy all properties from source galaxy to destination galaxy
 * @param dest Destination galaxy
 * @param src Source galaxy
 * @param params Pointer to runtime parameters
 * @return 0 on success, non-zero on failure
 */
int copy_galaxy_properties(struct GALAXY *dest, const struct GALAXY *src, const struct params *params)
{{
    if (dest == NULL || src == NULL) {{
        LOG_ERROR("NULL galaxy pointer in property copy");
        return -1;
    }}
    
    /* Free existing destination properties if present */
    free_galaxy_properties(dest);
    
    /* Allocate new properties */
    if (allocate_galaxy_properties(dest, params) != 0) {{
        return -1;
    }}
    
    /* Copy fixed-size fields */
{copy_fixed_fields_code}

    /* Copy dynamic arrays */
{copy_dynamic_arrays_code}
    
    return 0;
}}

/**
 * @brief Reset properties to initial values
 */
void reset_galaxy_properties(struct GALAXY *g)
{{
    if (g == NULL || g->properties == NULL) {{
        LOG_ERROR("Cannot reset properties for NULL galaxy or property pointer");
        return;
    }}
    
    /* Reset fixed properties to initial values */
{reset_property_values_code}
}}

/**
 * @brief Get property name string for a property ID
 */
const char* get_property_name(property_id_t id)
{{
    if (id >= 0 && id < PROP_COUNT) {{
        return PROPERTY_META[id].name;
    }}
    return NULL;
}}

/**
 * @brief Get property ID for a property name
 */
property_id_t get_property_id(const char *name)
{{
    if (name == NULL) {{
        return PROP_COUNT;
    }}
    
    for (int i = 0; i < PROP_COUNT; i++) {{
        if (strcmp(PROPERTY_META[i].name, name) == 0) {{
            return (property_id_t)i;
        }}
    }}
    
    return PROP_COUNT;
}}

/* Additional helper functions for property system */
{additional_helper_functions}
"""

# C type mapping
C_TYPE_MAP = {
    "int": "int",
    "int32_t": "int32_t",
    "uint32_t": "uint32_t",
    "int64_t": "int64_t",
    "uint64_t": "uint64_t",
    "long long": "long long",
    "float": "float",
    "double": "double",
    "bool": "bool",
    "char": "char",
}

def filter_properties_by_modules(properties, active_modules=None):
    """Filter properties based on active modules"""
    if active_modules is None:
        active_modules = []
    
    # Always include core properties
    filtered_properties = []
    
    for prop in properties:
        # Always include core properties
        if prop.get('is_core', False):
            filtered_properties.append(prop)
            continue
            
        # For physics properties, check if any required module is active
        required_modules = prop.get('required_modules', [])
        if not required_modules:
            # Property has no module requirements - include only if modules are active
            if active_modules:
                filtered_properties.append(prop)
        else:
            # Property has module requirements - include if any required module is active
            if any(module in active_modules for module in required_modules):
                filtered_properties.append(prop)
    
    return filtered_properties

def sanitize_include_guard(filename):
    """Convert a filename to a valid C include guard name"""
    base = os.path.basename(filename)
    base = os.path.splitext(base)[0].upper()
    return f"{base}_H"

def get_active_modules_from_config(config_file=None):
    """Extract active modules from configuration file"""
    if not config_file or not os.path.exists(config_file):
        return []
    
    try:
        with open(config_file, 'r') as f:
            import json
            config = json.load(f)
            
        modules_instances = config.get('modules', {}).get('instances', [])
        active_modules = []
        
        for instance in modules_instances:
            if instance.get('enabled', True):
                module_name = instance.get('name', '')
                if module_name:
                    active_modules.append(module_name)
        
        return active_modules
    except Exception as e:
        print(f"Warning: Failed to parse config file {config_file}: {e}")
        return []
    """Convert a filename to a valid C include guard name"""
    base = os.path.basename(filename)
    base = os.path.splitext(base)[0].upper()
    return f"{base}_H"

def parse_type(type_str):
    """Parse a type string and determine base type, array dimensions, and if it's dynamic"""
    is_array = False
    array_dim = 0
    is_dynamic = False
    base_type = type_str
    size_spec = ""
    
    # Check for array syntax: type[size] or type[]
    array_match = re.match(r'(\w+)(?:\[(\w*)\])+', type_str)
    if array_match:
        is_array = True
        base_type = array_match.group(1)
        size_spec = array_match.group(2)
        
        if size_spec == "":
            # Dynamic array: type[]
            is_dynamic = True
        else:
            # Fixed array: type[SIZE]
            array_dim = size_spec
    
    return base_type, is_array, array_dim, is_dynamic, size_spec

def generate_property_id_enum(properties):
    """Generate property ID enumeration from properties list"""
    enum_lines = []
    for prop in properties:
        enum_lines.append(f"    PROP_{prop['name']},")
    return "\n".join(enum_lines)

def generate_property_struct_fields(properties):
    """Generate struct fields for the galaxy_properties_t structure"""
    fields = []
    
    for prop in properties:
        # Get type information
        type_str = prop['type']
        base_type, is_array, array_dim, is_dynamic, size_spec = parse_type(type_str)
        
        # Generate field declarations
        if is_array:
            if is_dynamic:
                # Dynamic array with size field
                fields.append(f"    {base_type} *{prop['name']};")
                fields.append(f"    int {prop['name']}_size;")
            else:
                # Fixed-size array
                fields.append(f"    {base_type} {prop['name']}[{array_dim}];")
        else:
            # Simple scalar field
            fields.append(f"    {base_type} {prop['name']};")
    
    return "\n".join(fields)

def generate_property_accessor_macros(properties):
    """Generate accessor macros for all properties"""
    macros = []
    
    # Add the safe array access macro at the beginning
    macros.append("""/**
 * @brief Safely access an element of a galaxy property array with bounds checking.
 * @param g Pointer to the GALAXY struct.
 * @param prop_base_name The base name of the property (e.g., StarFormationHistory).
 * @param idx The index to access.
 * @param default_val The value to return if the index is out of bounds.
 * @return The array element value or default_val on error.
 */
#define GALAXY_PROP_ARRAY_SAFE(g, prop_base_name, idx, default_val) \\
    (((idx) >= 0 && (idx) < (g)->properties->prop_base_name##_size) ? \\
     ((g)->properties->prop_base_name[idx]) : \\
     (LOG_ERROR("Array index out of bounds: %s[%d] (size: %d)", #prop_base_name, (idx), (g)->properties->prop_base_name##_size), (default_val)))
""")
    
    for prop in properties:
        # Get type information
        type_str = prop['type']
        base_type, is_array, array_dim, is_dynamic, size_spec = parse_type(type_str)
        
        read_only = prop.get('read_only', False)
        read_only_comment = ""
        if read_only and read_only != "false":
            read_only_comment = " /* Read-only" + (" after first set" if read_only == "after_first_set" else "") + " */"
            
        # Generate accessor macro
        macros.append(f"#define GALAXY_PROP_{prop['name']}(g) ((g)->properties->{prop['name']}){read_only_comment}")
        
        # Add element accessor for arrays
        if is_array:
            if is_dynamic:
                # Add size accessor for dynamic arrays
                macros.append(f"#define GALAXY_PROP_{prop['name']}_SIZE(g) ((g)->properties->{prop['name']}_size)")
            
            # Element accessor works for both fixed and dynamic arrays
            macros.append(f"#define GALAXY_PROP_{prop['name']}_ELEM(g, idx) ((g)->properties->{prop['name']}[idx])")
            
            # For dynamic arrays, add a size setter function declaration
            if is_dynamic:
                macros.append(f"\nint galaxy_set_{prop['name']}_size(struct GALAXY *g, int size);")
                
        macros.append("")  # Add blank line between property accessors
    
    return "\n".join(macros)

def generate_property_meta_entries(properties):
    """Generate property metadata array entries"""
    meta_entries = []
    
    for i, prop in enumerate(properties):
        # Get type information
        type_str = prop['type']
        base_type, is_array, array_dim, is_dynamic, size_spec = parse_type(type_str)
        
        # Convert read_only to int value (0=false, 1=true, 2=after_first_set)
        read_only = prop.get('read_only', False)
        read_only_val = 0
        if read_only == True or read_only == "true":
            read_only_val = 1
        elif read_only == "after_first_set":
            read_only_val = 2
            
        # Size parameter for dynamic arrays
        size_param = "NULL"
        if is_dynamic and 'size_parameter' in prop:
            size_param = f'"{prop["size_parameter"]}"'
        
        # Format the entry
        entry = f"""    /* PROP_{prop['name']} */
    {{
        "{prop['name']}",
        "{type_str}",
        "{prop.get('units', 'dimensionless')}",
        "{prop.get('description', '')}",
        {str(prop.get('output', True)).lower()},
        {read_only_val},
        {str(is_array).lower()},
        {array_dim if array_dim else 0},
        {size_param}
    }}"""
        
        # Add comma if not the last entry
        if i < len(properties) - 1:
            entry += ","
            
        meta_entries.append(entry)
    
    return "\n".join(meta_entries)

def generate_transformer_externs(properties):
    """Generate extern declarations for transformer functions"""
    externs = []
    transformer_funcs = set()
    
    for prop in properties:
        if 'output_transformer_function' in prop:
            func_name = prop['output_transformer_function']
            if func_name not in transformer_funcs:
                transformer_funcs.add(func_name)
                externs.append(f"extern int {func_name}(const struct GALAXY *galaxy, property_id_t output_prop_id, "
                              f"void *output_buffer_element_ptr, const struct params *run_params);")
    
    return "\n".join(externs)

def generate_transformer_dispatch_chain(properties):
    """Generate if/else chain for the dispatcher function"""
    chains = []
    
    for prop in properties:
        if 'output_transformer_function' in prop:
            func_name = prop['output_transformer_function']
            chains.append(f"""    if (strcmp(output_prop_name, "{prop['name']}") == 0) {{
        status = {func_name}(galaxy, output_prop_id, output_buffer_element_ptr, run_params);
    }}""")
    
    # Join with "else" for all entries except the last one
    if chains:
        for i in range(1, len(chains)):
            chains[i] = "else " + chains[i]
        # Add the default else clause when there are transformers
        chains.append("""    else {
        // Default identity transformation for properties without a transformer
        if (galaxy->properties == NULL) {
            LOG_ERROR("Galaxy properties is NULL for property '%s'", output_prop_name);
            return -1;
        }
        
        // This uses the output_prop_id to fetch the raw value
        if (h5_dtype == H5T_NATIVE_FLOAT) {
            *((float*)output_buffer_element_ptr) = get_float_property(galaxy, output_prop_id, 0.0f);
        } else if (h5_dtype == H5T_NATIVE_DOUBLE) {
            *((double*)output_buffer_element_ptr) = get_double_property(galaxy, output_prop_id, 0.0);
        } else if (h5_dtype == H5T_NATIVE_INT) {
            *((int32_t*)output_buffer_element_ptr) = get_int32_property(galaxy, output_prop_id, 0);
        } else if (h5_dtype == H5T_NATIVE_LLONG) {
            // Assuming int64_t for H5T_NATIVE_LLONG output
            *((int64_t*)output_buffer_element_ptr) = get_int64_property(galaxy, output_prop_id, 0LL);
        } else {
            LOG_ERROR("Unsupported HDF5 type for default identity transform of property '%s'", output_prop_name);
            status = -1;
        }
    }""")
        return "\n".join(chains)
    else:
        # No transformers available - provide default identity transformation only
        return """    // Default identity transformation (no custom transformers available)
    (void)run_params; /* No custom transformers use run_params */
    
    if (galaxy->properties == NULL) {
        LOG_ERROR("Galaxy properties is NULL for property '%s'", output_prop_name);
        return -1;
    }
    
    // Check for component-wise array access first
    if (strlen(output_prop_name) >= 4) {
        char last_char = output_prop_name[strlen(output_prop_name) - 1];
        if (last_char == 'x' || last_char == 'y' || last_char == 'z') {
            // Extract component index from name suffix
            int component_idx = -1;
            if (last_char == 'x') component_idx = 0;
            else if (last_char == 'y') component_idx = 1;
            else if (last_char == 'z') component_idx = 2;
            
            // Handle known 3-element arrays
            if (strncmp(output_prop_name, "Pos", 3) == 0 && strlen(output_prop_name) == 4) {
                *((float*)output_buffer_element_ptr) = GALAXY_PROP_Pos_ELEM(galaxy, component_idx);
            }
            else if (strncmp(output_prop_name, "Vel", 3) == 0 && strlen(output_prop_name) == 4) {
                *((float*)output_buffer_element_ptr) = GALAXY_PROP_Vel_ELEM(galaxy, component_idx);
            }
            else if (strncmp(output_prop_name, "Spin", 4) == 0 && strlen(output_prop_name) == 5) {
                *((float*)output_buffer_element_ptr) = GALAXY_PROP_Spin_ELEM(galaxy, component_idx);
            }
            else {
                // Not a recognized array component, fall through to regular property access
                goto regular_property_access;
            }
            return status; // Component handled successfully
        }
    }
    
    regular_property_access:
    // Regular property access using the property ID
    if (h5_dtype == H5T_NATIVE_FLOAT) {
        *((float*)output_buffer_element_ptr) = get_float_property(galaxy, output_prop_id, 0.0f);
    } else if (h5_dtype == H5T_NATIVE_DOUBLE) {
        *((double*)output_buffer_element_ptr) = get_double_property(galaxy, output_prop_id, 0.0);
    } else if (h5_dtype == H5T_NATIVE_INT) {
        *((int32_t*)output_buffer_element_ptr) = get_int32_property(galaxy, output_prop_id, 0);
    } else if (h5_dtype == H5T_NATIVE_LLONG) {
        // Handle specific signed 64-bit properties
        if (output_prop_id == PROP_MostBoundID) {
            *((int64_t*)output_buffer_element_ptr) = GALAXY_PROP_MostBoundID(galaxy);
        } else if (output_prop_id == PROP_SimulationHaloIndex) {
            *((int64_t*)output_buffer_element_ptr) = GALAXY_PROP_SimulationHaloIndex(galaxy);
        } else {
            LOG_ERROR("Unsupported signed 64-bit property '%s' (ID: %d)", output_prop_name, output_prop_id);
            *((int64_t*)output_buffer_element_ptr) = 0;
        }
    } else if (h5_dtype == H5T_NATIVE_ULLONG) {
        // Handle specific unsigned 64-bit properties
        if (output_prop_id == PROP_GalaxyIndex) {
            *((uint64_t*)output_buffer_element_ptr) = GALAXY_PROP_GalaxyIndex(galaxy);
        } else if (output_prop_id == PROP_CentralGalaxyIndex) {
            *((uint64_t*)output_buffer_element_ptr) = GALAXY_PROP_CentralGalaxyIndex(galaxy);
        } else {
            LOG_ERROR("Unsupported unsigned 64-bit property '%s' (ID: %d)", output_prop_name, output_prop_id);
            *((uint64_t*)output_buffer_element_ptr) = 0;
        }
    } else {
        LOG_ERROR("Unsupported HDF5 type for default identity transform of property '%s'", output_prop_name);
        status = -1;
    }"""

def generate_transformers_file(properties, output_dir=""):
    """Generate the output transformers file"""
    transformers_filename = "generated_output_transformers.c"
    output_path = os.path.join(output_dir, transformers_filename)
    
    # Generate components
    transformer_function_externs = generate_transformer_externs(properties)
    dispatcher_if_chain = generate_transformer_dispatch_chain(properties)
    
    # Fill in the template
    transformers_content = TRANSFORMERS_TEMPLATE.format(
        transformers_filename=transformers_filename,
        timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        transformer_function_externs=transformer_function_externs,
        dispatcher_if_chain=dispatcher_if_chain
    )
    
    # Write the output transformers file
    with open(output_path, "w") as f:
        f.write(transformers_content)
    
    print(f"Generated {output_path}")

def generate_initialize_code(properties):
    """Generate code for initializing the property system"""
    code_lines = []
    
    code_lines.append("    if (params == NULL) {")
    code_lines.append("        LOG_ERROR(\"Params pointer is NULL during property system initialization.\");")
    code_lines.append("        return -1;")
    code_lines.append("    }")
    code_lines.append("    LOG_DEBUG(\"Validating dynamic array size parameters...\");")
    code_lines.append("    for (int i = 0; i < PROP_COUNT; i++) {")
    code_lines.append("        if (PROPERTY_META[i].is_array && PROPERTY_META[i].array_dimension == 0 &&")
    code_lines.append("            PROPERTY_META[i].size_parameter != NULL) {")
    code_lines.append("            int size = resolve_parameter_value(PROPERTY_META[i].size_parameter, params);")
    code_lines.append("            if (size < 0) {") # Check for negative size (error from resolve)
    code_lines.append("                LOG_ERROR(\"Failed to resolve or invalid size parameter '%s' for dynamic array '%s'\",")
    code_lines.append("                         PROPERTY_META[i].size_parameter, PROPERTY_META[i].name);")
    code_lines.append("                return -1; // Fail initialization")
    code_lines.append("            }")
    code_lines.append("            LOG_DEBUG(\"Validated size parameter '%s' for dynamic array '%s' (resolved size: %d)\",")
    code_lines.append("                       PROPERTY_META[i].size_parameter, PROPERTY_META[i].name, size);")
    code_lines.append("        }")
    code_lines.append("    }")
    
    return "\n".join(code_lines)

def generate_allocate_arrays_code(properties):
    """Generate code for allocating dynamic arrays"""
    code_lines = []
    
    # Find properties with dynamic arrays
    dynamic_arrays = [p for p in properties if parse_type(p['type'])[3]]
    if dynamic_arrays:
        # Add static counters for interval-based debug logging
        code_lines.append("    /* Static counters for interval-based debug logging */")
        for prop in dynamic_arrays:
            code_lines.append(f"    static int debug_count_{prop['name']} = 0;")
        code_lines.append("")
        
        for prop in dynamic_arrays:
            base_type = parse_type(prop['type'])[0]
            is_core = prop.get('is_core', True)  # Default to true for safety
            
            prop_type_comment = "core" if is_core else "physics"
            code_lines.append(f"    /* {prop['name']} - {prop_type_comment} dynamic array, always allocate if present in build */")
                        
            # Standard allocation logic (indented for physics properties)
            indent = "        "
            code_lines.extend([
                f"{indent}if (PROPERTY_META[PROP_{prop['name']}].size_parameter != NULL) {{",
                f"{indent}    // Get size from parameters",
                f"{indent}    int resolved_size = resolve_parameter_value(PROPERTY_META[PROP_{prop['name']}].size_parameter, params);",
                f"{indent}    if (resolved_size < 0) {{",
                f"{indent}        LOG_ERROR(\"Failed to resolve size for dynamic array '{prop['name']}' during allocation\");",
                f"{indent}        free_galaxy_properties(g); // Cleanup partially allocated",
                f"{indent}        return -1;",
                f"{indent}    }}",
                f"{indent}    // Call the specific generated size setter",
                f"{indent}    int status = galaxy_set_{prop['name']}_size(g, resolved_size);",
                f"{indent}    if (status != 0) {{",
                f"{indent}        LOG_ERROR(\"Failed to set size and allocate for dynamic array '{prop['name']}'\");",
                f"{indent}        free_galaxy_properties(g); // Cleanup partially allocated",
                f"{indent}        return -1;",
                f"{indent}    }}",
                f"{indent}    // Interval-based debug logging (first 5 allocations only)",
                f"{indent}    debug_count_{prop['name']}++;",
                f"{indent}    if (debug_count_{prop['name']} <= 5) {{",
                f"{indent}        if (debug_count_{prop['name']} == 5) {{",
                f"{indent}            LOG_DEBUG(\"Allocated dynamic array '{prop['name']}' with size %d (further messages suppressed)\", resolved_size);",
                f"{indent}        }} else {{",
                f"{indent}            LOG_DEBUG(\"Allocated dynamic array '{prop['name']}' with size %d\", resolved_size);",
                f"{indent}        }}",
                f"{indent}    }}",
                f"{indent}}}"
            ])
    
    return "\n".join(code_lines)

def generate_free_arrays_code(properties):
    """Generate code for freeing dynamic arrays"""
    code_lines = []
    
    # Find properties with dynamic arrays
    dynamic_arrays = [p for p in properties if parse_type(p['type'])[3]]
    if dynamic_arrays:
        for prop in dynamic_arrays:
            code_lines.extend([
                f"    /* Free {prop['name']} array */",
                f"    if (g->properties->{prop['name']} != NULL) {{",
                f"        free(g->properties->{prop['name']});",
                f"        g->properties->{prop['name']} = NULL;",
                f"        g->properties->{prop['name']}_size = 0;",
                f"    }}"
            ])
    
    return "\n".join(code_lines)

def generate_copy_fixed_fields_code(properties):
    """Generate code for copying fixed-size fields"""
    return """    /* Copy fixed-size fields */
    /* Save the correct SnapNum from source galaxy before memcpy */
    int correct_snapnum = src->SnapNum;
    
    /* Copy the basic structure */
    memcpy(dest->properties, src->properties, sizeof(galaxy_properties_t));
    
    /* Restore the correct SnapNum in the copied properties */
    dest->properties->SnapNum = correct_snapnum;

    /* Reset dynamic array pointers to NULL to avoid double-free issues */""" + '\n'.join([
        f"    dest->properties->{p['name']} = NULL;" 
        for p in properties if parse_type(p['type'])[3]
    ])

def generate_copy_dynamic_arrays_code(properties):
    """Generate code for copying dynamic arrays"""
    code_lines = []
    
    # Find properties with dynamic arrays
    dynamic_arrays = [p for p in properties if parse_type(p['type'])[3]]
    if dynamic_arrays:
        for prop in dynamic_arrays:
            base_type = parse_type(prop['type'])[0]
            code_lines.extend([
                f"    /* Copy {prop['name']} array */",
                f"    if (src->properties->{prop['name']} != NULL && src->properties->{prop['name']}_size > 0) {{",
                f"        int size = src->properties->{prop['name']}_size;",
                f"        dest->properties->{prop['name']} = ({base_type} *)malloc(size * sizeof({base_type}));",
                f"        if (dest->properties->{prop['name']} == NULL) {{",
                f"            LOG_ERROR(\"Failed to allocate memory for {prop['name']} property during copy\");",
                f"            return -1;",
                f"        }}",
                f"        dest->properties->{prop['name']}_size = size;",
                f"        memcpy(dest->properties->{prop['name']}, src->properties->{prop['name']}, size * sizeof({base_type}));",
                f"    }}",
            ])
    
    return "\n".join(code_lines)

def generate_reset_property_values_code(properties):
    """Generate code for resetting properties to initial values"""
    code_lines = []
    
    # Reset all properties to their initial values
    for prop in properties:
        type_str = prop['type']
        base_type, is_array, array_dim, is_dynamic, size_spec = parse_type(type_str)
        initial_value = prop.get('initial_value', 0)
        
        if is_array:
            if is_dynamic:
                # Dynamic arrays - don't reset, just leave as is
                continue
            
            if isinstance(initial_value, list):
                # List of initial values for array elements
                for i, val in enumerate(initial_value):
                    if i < int(array_dim):  # Only set values that fit in the array
                        code_lines.append(f"    g->properties->{prop['name']}[{i}] = {val}f;")
            else:
                # Single initial value for all elements
                code_lines.append(f"    for (int i = 0; i < {array_dim}; i++) {{")
                code_lines.append(f"        g->properties->{prop['name']}[i] = {initial_value}f;")
                code_lines.append(f"    }}")
        else:
            # Simple scalar field
            suffix = ""
            if base_type == "float":
                suffix = "f"
            elif base_type == "double":
                suffix = ""  # No suffix for double
                
            code_lines.append(f"    g->properties->{prop['name']} = {initial_value}{suffix};")
    
    return "\n".join(code_lines)

def generate_float_dispatcher(properties):
    """Generate the float property dispatcher function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Get a float property value by property ID")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding field in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement. This provides type-safe")
    c_code.append(" * access to properties without requiring compile-time knowledge of the specific")
    c_code.append(" * property names.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to access")
    c_code.append(" * @param default_value Value to return in case of error")
    c_code.append(" * @return The property value or default_value on error")
    c_code.append(" */")
    c_code.append("float get_generated_float(const galaxy_properties_t *props, property_id_t prop_id, float default_value) {")
    c_code.append("    if (!props) return default_value;")
    c_code.append("    switch (prop_id) {")
    
    # Add case for each float property
    for prop in properties:
        base_type, is_array, _, is_dynamic, _ = parse_type(prop['type'])
        if not is_array and base_type == 'float':
            c_code.append(f"        case PROP_{prop['name']}: return props->{prop['name']};")
    
    c_code.append("        default: return default_value;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_float_setter(properties):
    """Generate the float property setter function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Set a float property value by property ID")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding field in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement. This provides type-safe")
    c_code.append(" * access to properties without requiring compile-time knowledge of the specific")
    c_code.append(" * property names.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to set")
    c_code.append(" * @param value Value to set property to")
    c_code.append(" */")
    c_code.append("void set_generated_float(galaxy_properties_t *props, property_id_t prop_id, float value) {")
    c_code.append("    if (!props) return;")
    c_code.append("    switch (prop_id) {")
    
    # Add case for each float property
    for prop in properties:
        base_type, is_array, _, is_dynamic, _ = parse_type(prop['type'])
        if not is_array and base_type == 'float':
            c_code.append(f"        case PROP_{prop['name']}: props->{prop['name']} = value; break;")
    
    c_code.append("        default: break;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_int32_dispatcher(properties):
    """Generate the int32 property dispatcher function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Get an int32 property value by property ID")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding field in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement. This provides type-safe")
    c_code.append(" * access to properties without requiring compile-time knowledge of the specific")
    c_code.append(" * property names.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to access")
    c_code.append(" * @param default_value Value to return in case of error")
    c_code.append(" * @return The property value or default_value on error")
    c_code.append(" */")
    c_code.append("int32_t get_generated_int32(const galaxy_properties_t *props, property_id_t prop_id, int32_t default_value) {")
    c_code.append("    if (!props) return default_value;")
    c_code.append("    switch (prop_id) {")
    
    # Add case for each int32 property
    for prop in properties:
        base_type, is_array, _, is_dynamic, _ = parse_type(prop['type'])
        if not is_array and (base_type == 'int32_t' or base_type == 'int'):
            c_code.append(f"        case PROP_{prop['name']}: return props->{prop['name']};")
    
    c_code.append("        default: return default_value;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_float_array_setter(properties):
    """Generate the float array element property setter function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Set a float array element value by property ID and index")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding array field in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement, then sets the specified")
    c_code.append(" * array element. This provides type-safe access to array properties without requiring")
    c_code.append(" * compile-time knowledge of the specific property names.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to access")
    c_code.append(" * @param array_idx Index of the array element to set")
    c_code.append(" * @param value Value to set the array element to")
    c_code.append(" */")
    c_code.append("void set_generated_float_array_element(galaxy_properties_t *props, property_id_t prop_id, int array_idx, float value) {")
    c_code.append("    if (!props) return;")
    c_code.append("    ")
    c_code.append("    // Validate array index")
    c_code.append("    if (array_idx < 0) return;")
    c_code.append("    ")
    c_code.append("    switch (prop_id) {")
    
    # Add case for each float array property
    for prop in properties:
        base_type, is_array, array_dim, is_dynamic, _ = parse_type(prop['type'])
        if is_array and base_type == 'float':
            if is_dynamic:
                # Dynamic array with a size field
                c_code.append(f"        case PROP_{prop['name']}:")
                c_code.append(f"            if (array_idx >= props->{prop['name']}_size || !props->{prop['name']}) return;")
                c_code.append(f"            props->{prop['name']}[array_idx] = value;")
                c_code.append(f"            break;")
            else:
                # Fixed size array
                c_code.append(f"        case PROP_{prop['name']}:")
                c_code.append(f"            if (array_idx >= {array_dim}) return;")
                c_code.append(f"            props->{prop['name']}[array_idx] = value;")
                c_code.append(f"            break;")
    
    c_code.append("        default: break;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_int32_setter(properties):
    """Generate the int32 property setter function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Set an int32 property value by property ID")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding field in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement. This provides type-safe")
    c_code.append(" * access to properties without requiring compile-time knowledge of the specific")
    c_code.append(" * property names.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to set")
    c_code.append(" * @param value Value to set property to")
    c_code.append(" */")
    c_code.append("void set_generated_int32(galaxy_properties_t *props, property_id_t prop_id, int32_t value) {")
    c_code.append("    if (!props) return;")
    c_code.append("    switch (prop_id) {")
    
    # Add case for each int32 property
    for prop in properties:
        base_type, is_array, _, is_dynamic, _ = parse_type(prop['type'])
        if not is_array and (base_type == 'int32_t' or base_type == 'int'):
            c_code.append(f"        case PROP_{prop['name']}: props->{prop['name']} = value; break;")
    
    c_code.append("        default: break;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_double_dispatcher(properties):
    """Generate the double property dispatcher function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Get a double property value by property ID")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding field in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement. This provides type-safe")
    c_code.append(" * access to properties without requiring compile-time knowledge of the specific")
    c_code.append(" * property names.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to access")
    c_code.append(" * @param default_value Value to return in case of error")
    c_code.append(" * @return The property value or default_value on error")
    c_code.append(" */")
    c_code.append("double get_generated_double(const galaxy_properties_t *props, property_id_t prop_id, double default_value) {")
    c_code.append("    if (!props) return default_value;")
    c_code.append("    switch (prop_id) {")
    
    # Add case for each double property
    for prop in properties:
        base_type, is_array, _, is_dynamic, _ = parse_type(prop['type'])
        if not is_array and base_type == 'double':
            c_code.append(f"        case PROP_{prop['name']}: return props->{prop['name']};")
    
    c_code.append("        default: return default_value;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_double_setter(properties):
    """Generate the double property setter function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Set a double property value by property ID")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding field in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement. This provides type-safe")
    c_code.append(" * access to properties without requiring compile-time knowledge of the specific")
    c_code.append(" * property names.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to set")
    c_code.append(" * @param value Value to set property to")
    c_code.append(" */")
    c_code.append("void set_generated_double(galaxy_properties_t *props, property_id_t prop_id, double value) {")
    c_code.append("    if (!props) return;")
    
    # Check if there are any double properties
    has_double_properties = any(
        not parse_type(prop['type'])[1] and parse_type(prop['type'])[0] == 'double' 
        for prop in properties
    )
    
    if not has_double_properties:
        c_code.append("    (void)prop_id; /* No double properties available */")
        c_code.append("    (void)value;   /* No double properties available */")
    
    c_code.append("    switch (prop_id) {")
    
    # Add case for each double property
    for prop in properties:
        base_type, is_array, _, is_dynamic, _ = parse_type(prop['type'])
        if not is_array and base_type == 'double':
            c_code.append(f"        case PROP_{prop['name']}: props->{prop['name']} = value; break;")
    
    c_code.append("        default: break;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_float_array_dispatcher(properties):
    """Generate the float array element property dispatcher function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Get a float array element value by property ID and index")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding array field in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement, then accesses the specified")
    c_code.append(" * array element. This provides type-safe access to array properties without requiring")
    c_code.append(" * compile-time knowledge of the specific property names.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to access")
    c_code.append(" * @param array_idx Index of the array element to access")
    c_code.append(" * @param default_value Value to return in case of error")
    c_code.append(" * @return The array element value or default_value on error")
    c_code.append(" */")
    c_code.append("float get_generated_float_array_element(const galaxy_properties_t *props, property_id_t prop_id, int array_idx, float default_value) {")
    c_code.append("    if (!props) return default_value;")
    c_code.append("    ")
    c_code.append("    // Validate array index")
    c_code.append("    if (array_idx < 0) return default_value;")
    c_code.append("    ")
    c_code.append("    switch (prop_id) {")
    
    # Add case for each float array property
    for prop in properties:
        base_type, is_array, array_dim, is_dynamic, _ = parse_type(prop['type'])
        if is_array and base_type == 'float':
            if is_dynamic:
                # Dynamic array with a size field
                c_code.append(f"        case PROP_{prop['name']}:")
                c_code.append(f"            if (array_idx >= props->{prop['name']}_size || !props->{prop['name']}) return default_value;")
                c_code.append(f"            return props->{prop['name']}[array_idx];")
            else:
                # Fixed size array
                c_code.append(f"        case PROP_{prop['name']}:")
                c_code.append(f"            if (array_idx >= {array_dim}) return default_value;")
                c_code.append(f"            return props->{prop['name']}[array_idx];")
    
    c_code.append("        default: return default_value;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_int32_array_dispatcher(properties):
    """Generate the int32 array element property dispatcher function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Get an int32 array element value by property ID and index")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding array field in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement, then accesses the specified")
    c_code.append(" * array element. This provides type-safe access to array properties without requiring")
    c_code.append(" * compile-time knowledge of the specific property names.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to access")
    c_code.append(" * @param array_idx Index of the array element to access")
    c_code.append(" * @param default_value Value to return in case of error")
    c_code.append(" * @return The array element value or default_value on error")
    c_code.append(" */")
    c_code.append("int32_t get_generated_int32_array_element(const galaxy_properties_t *props, property_id_t prop_id, int array_idx, int32_t default_value) {")
    c_code.append("    if (!props) return default_value;")
    c_code.append("    ")
    c_code.append("    // Validate array index")
    c_code.append("    if (array_idx < 0) return default_value;")
    c_code.append("    ")
    c_code.append("    switch (prop_id) {")
    
    # Add case for each int32 array property
    for prop in properties:
        base_type, is_array, array_dim, is_dynamic, _ = parse_type(prop['type'])
        if is_array and (base_type == 'int32_t' or base_type == 'int'):
            if is_dynamic:
                # Dynamic array with a size field
                c_code.append(f"        case PROP_{prop['name']}:")
                c_code.append(f"            if (array_idx >= props->{prop['name']}_size || !props->{prop['name']}) return default_value;")
                c_code.append(f"            return props->{prop['name']}[array_idx];")
            else:
                # Fixed size array
                c_code.append(f"        case PROP_{prop['name']}:")
                c_code.append(f"            if (array_idx >= {array_dim}) return default_value;")
                c_code.append(f"            return props->{prop['name']}[array_idx];")
    
    c_code.append("        default: return default_value;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_double_array_dispatcher(properties):
    """Generate the double array element property dispatcher function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Get a double array element value by property ID and index")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding array field in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement, then accesses the specified")
    c_code.append(" * array element. This provides type-safe access to array properties without requiring")
    c_code.append(" * compile-time knowledge of the specific property names.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to access")
    c_code.append(" * @param array_idx Index of the array element to access")
    c_code.append(" * @param default_value Value to return in case of error")
    c_code.append(" * @return The array element value or default_value on error")
    c_code.append(" */")
    c_code.append("double get_generated_double_array_element(const galaxy_properties_t *props, property_id_t prop_id, int array_idx, double default_value) {")
    c_code.append("    if (!props) return default_value;")
    c_code.append("    ")
    c_code.append("    // Validate array index")
    c_code.append("    if (array_idx < 0) return default_value;")
    c_code.append("    ")
    c_code.append("    switch (prop_id) {")
    
    # Add case for each double array property
    for prop in properties:
        base_type, is_array, array_dim, is_dynamic, _ = parse_type(prop['type'])
        if is_array and base_type == 'double':
            if is_dynamic:
                # Dynamic array with a size field
                c_code.append(f"        case PROP_{prop['name']}:")
                c_code.append(f"            if (array_idx >= props->{prop['name']}_size || !props->{prop['name']}) return default_value;")
                c_code.append(f"            return props->{prop['name']}[array_idx];")
            else:
                # Fixed size array
                c_code.append(f"        case PROP_{prop['name']}:")
                c_code.append(f"            if (array_idx >= {array_dim}) return default_value;")
                c_code.append(f"            return props->{prop['name']}[array_idx];")
    
    c_code.append("        default: return default_value;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_array_size_dispatcher(properties):
    """Generate the array size dispatcher function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Get the size of an array property by property ID")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding array size in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement. For dynamic arrays, this returns")
    c_code.append(" * the size field value. For fixed arrays, it returns the compile-time array dimension.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to access")
    c_code.append(" * @return The array size or 0 on error/not an array")
    c_code.append(" */")
    c_code.append("int get_generated_array_size(const galaxy_properties_t *props, property_id_t prop_id) {")
    c_code.append("    if (!props) return 0;")
    c_code.append("    ")
    c_code.append("    switch (prop_id) {")
    
    # Add case for each array property
    for prop in properties:
        base_type, is_array, array_dim, is_dynamic, _ = parse_type(prop['type'])
        if is_array:
            if is_dynamic:
                # Dynamic array with a size field
                c_code.append(f"        case PROP_{prop['name']}: return props->{prop['name']}_size;")
            else:
                # Fixed size array
                c_code.append(f"        case PROP_{prop['name']}: return {array_dim};")
    
    c_code.append("        default: return 0;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_helper_functions(properties):
    """Generate additional helper functions for the property system"""
    functions = []
    
    # Add size setter functions for dynamic arrays
    dynamic_arrays = [p for p in properties if parse_type(p['type'])[3]]
    for prop in dynamic_arrays:
        base_type = parse_type(prop['type'])[0]
        
        # Start with standard function header and validation
        func_lines = [
            f"/**",
            f" * @brief Set the size of the {prop['name']} dynamic array",
            f" * @param g Galaxy pointer",
            f" * @param size New size for the array",
            f" * @return 0 on success, non-zero on failure",
            f" */",
            f"int galaxy_set_{prop['name']}_size(struct GALAXY *g, int size)",
            "{",
            f"    if (g == NULL || g->properties == NULL) {{",
            f"        LOG_ERROR(\"Cannot set size for NULL galaxy or property pointer\");",
            f"        return -1;",
            f"    }}",
            f"    ",
            f"    if (size < 0) {{",
            f"        LOG_ERROR(\"Cannot set negative size for {prop['name']} array\");",
            f"        return -1;",
            f"    }}",
            f"    if (size < 0) {{",
            f"        LOG_ERROR(\"Cannot set negative size for {prop['name']} array. Requested size: %d\", size);",
            f"        g->properties->{prop['name']}_size = 0; /* Ensure size is non-negative on error */",
            f"        if (g->properties->{prop['name']} != NULL) {{ free(g->properties->{prop['name']}); g->properties->{prop['name']} = NULL; }} /* Free if already allocated */",
            f"        return -1; /* Indicate error */",
            f"    }}",            
            f"    ",
            f"    /* Free existing array if present */",
            f"    if (g->properties->{prop['name']} != NULL) {{",
            f"        free(g->properties->{prop['name']});",
            f"        g->properties->{prop['name']} = NULL;",
            f"    }}",
            f"    ",
            f"    /* Set new size */",
            f"    g->properties->{prop['name']}_size = size;",
            f"    ",
            f"    /* Allocate new array if size > 0 */",
            f"    if (size > 0) {{",
            f"        g->properties->{prop['name']} = ({base_type} *)calloc(size, sizeof({base_type}));",
            f"        if (g->properties->{prop['name']} == NULL) {{",
            f"            LOG_ERROR(\"Failed to allocate memory for {prop['name']} array\");",
            f"            g->properties->{prop['name']}_size = 0;",
            f"            return -1;",
            f"        }}"
        ]
        
        # Check for non-zero initial value
        initial_value = prop.get('initial_value')
        if initial_value is not None and str(initial_value) != '0' and str(initial_value) != '0.0':
            func_lines.extend([
                f"        ",
                f"        /* Initialize array with non-zero value {initial_value} */",
                f"        for (int i = 0; i < size; i++) {{",
                f"            g->properties->{prop['name']}[i] = {initial_value};",
                f"        }}"
            ])
        
        # Add function closing
        func_lines.extend([
            f"    }}",
            f"    ",
            f"    return 0;",
            "}"
        ])
        
        # Add function lines to the overall functions list
        functions.extend(func_lines)
    
    return "\n".join(functions)

def generate_resolve_parameter_function():
    """Generate the resolve_parameter_value function"""
    return '''
/**
 * @brief Resolve a parameter name to its integer value
 * @param param_name Name of the parameter (e.g., "simulation.NumSnapOutputs")
 * @param params Pointer to the runtime parameters structure
 * @return Parameter value, or -1 on error
 */
static int resolve_parameter_value(const char *param_name, const struct params *params) {
    if (param_name == NULL || params == NULL) {
        LOG_ERROR("NULL parameter name or params pointer in resolve_parameter_value");
        return -1;
    }
    
    // Add specific parameter lookups here
    if (strcmp(param_name, "simulation.NumSnapOutputs") == 0) {
        // Ensure NumSnapOutputs is valid before returning
        if (params->simulation.NumSnapOutputs <= 0) {
            LOG_ERROR("Invalid value for simulation.NumSnapOutputs: %d", params->simulation.NumSnapOutputs);
            return -1;
        }
        return params->simulation.NumSnapOutputs;
    }
    // Add lookups for other potential size parameters here...
    // Example:
    // else if (strcmp(param_name, "some_other_section.some_size") == 0) {
    //     return params->some_other_section.some_size;
    // }

    LOG_ERROR("Unknown parameter name for dynamic array size: %s", param_name);
    return -1;
}
'''

def generate_header_file(properties, output_dir=""):
    """Generate the property header file"""
    header_filename = "core_properties.h"
    output_path = os.path.join(output_dir, header_filename)
    
    # Generate header components
    include_guard = sanitize_include_guard(header_filename)
    property_id_enum = generate_property_id_enum(properties)
    property_struct_fields = generate_property_struct_fields(properties)
    property_accessor_macros = generate_property_accessor_macros(properties)
    
    # Fill in the template
    header_content = HEADER_TEMPLATE.format(
        header_filename=header_filename,
        include_guard=include_guard,
        timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        property_id_enum=property_id_enum,
        property_struct_fields=property_struct_fields,
        property_accessor_macros=property_accessor_macros
    )
    
    # Write the header file
    with open(output_path, "w") as f:
        f.write(header_content)
    
    print(f"Generated {output_path}")

def generate_galaxy_property_info(properties):
    """Generate GalaxyPropertyInfo array initialization from properties"""
    info_entries = []
    
    for i, prop in enumerate(properties):
        # Get type information
        type_str = prop['type']
        base_type, is_array, array_dim, is_dynamic, size_spec = parse_type(type_str)
        
        # Convert read_only to int value (0=false, 1=true, 2=after_first_set)
        read_only = prop.get('read_only', False)
        read_only_level = 0
        if read_only == True or read_only == "true":
            read_only_level = 1
        elif read_only == "after_first_set":
            read_only_level = 2
        
        # Format the entry
        entry = f"""    {{
        /* name */           "{prop['name']}",
        /* units */          "{prop.get('units', 'dimensionless')}",
        /* description */    "{prop.get('description', '')}",
        /* type_str */       "{type_str}",
        /* is_array */       {str(is_array).lower()},
        /* is_dynamic_array */{str(is_dynamic).lower()},
        /* element_size */   sizeof({base_type}),
        /* array_len */      {array_dim if array_dim and not is_dynamic else 0},
        /* default_value */  NULL,
        /* output_field */   {str(prop.get('output', True)).lower()},
        /* read_only_level */{read_only_level}
    }}"""
        
        # Add comma if not the last entry
        if i < len(properties) - 1:
            entry += ","
            
        info_entries.append(entry)
    
    return "\n".join(info_entries)

def generate_implementation_file(properties, output_dir=""):
    """Generate the property implementation file"""
    from datetime import datetime
    
    impl_filename = "core_properties.c"
    header_filename = "core_properties.h"
    output_path = os.path.join(output_dir, impl_filename)
    
    # Count core properties
    core_property_count = 0
    for prop in properties:
        if prop.get('is_core', False):
            core_property_count += 1
    
    # Generate implementation components
    property_meta_entries = generate_property_meta_entries(properties)
    galaxy_property_info_entries = generate_galaxy_property_info(properties)
    initialize_property_system_code = generate_initialize_code(properties)
    allocate_dynamic_arrays_code = generate_allocate_arrays_code(properties)
    free_dynamic_arrays_code = generate_free_arrays_code(properties)
    copy_fixed_fields_code = generate_copy_fixed_fields_code(properties)
    copy_dynamic_arrays_code = generate_copy_dynamic_arrays_code(properties)
    reset_property_values_code = generate_reset_property_values_code(properties)
    additional_helper_functions = generate_helper_functions(properties)
    resolve_parameter_function = generate_resolve_parameter_function()
    
    # Generate the dispatcher functions
    float_dispatcher = generate_float_dispatcher(properties)
    int32_dispatcher = generate_int32_dispatcher(properties)
    double_dispatcher = generate_double_dispatcher(properties)
    float_array_dispatcher = generate_float_array_dispatcher(properties)
    int32_array_dispatcher = generate_int32_array_dispatcher(properties)
    double_array_dispatcher = generate_double_array_dispatcher(properties)
    array_size_dispatcher = generate_array_size_dispatcher(properties)
    
    # Modify the IMPLEMENTATION_TEMPLATE to add __attribute__((unused)) to params in allocate_galaxy_properties
    modified_template = IMPLEMENTATION_TEMPLATE.replace(
        "int allocate_galaxy_properties(struct GALAXY *g, const struct params *params)",
        "int allocate_galaxy_properties(struct GALAXY *g, const struct params *params __attribute__((unused)))"
    )
    
    # Fill in the template
    impl_content = modified_template.format(
        impl_filename=impl_filename,
        header_filename=header_filename,
        timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        property_meta_entries=property_meta_entries,
        initialize_property_system_code=initialize_property_system_code,
        allocate_dynamic_arrays_code=allocate_dynamic_arrays_code,
        free_dynamic_arrays_code=free_dynamic_arrays_code,
        copy_fixed_fields_code=copy_fixed_fields_code,
        copy_dynamic_arrays_code=copy_dynamic_arrays_code,
        reset_property_values_code=reset_property_values_code,
        additional_helper_functions=additional_helper_functions,
        resolve_parameter_function=resolve_parameter_function
    )
    
    # Add the dispatcher functions to the implementation file
    impl_content += "\n\n/* Generated property dispatcher functions */\n\n"
    impl_content += float_dispatcher + "\n\n"
    impl_content += int32_dispatcher + "\n\n"
    impl_content += double_dispatcher + "\n\n"
    impl_content += float_array_dispatcher + "\n\n"
    impl_content += int32_array_dispatcher + "\n\n"
    impl_content += double_array_dispatcher + "\n\n"
    impl_content += array_size_dispatcher + "\n\n"
    
    # Add the setter functions to the implementation file
    impl_content += "\n\n/* Generated property setter functions */\n\n"
    impl_content += generate_float_setter(properties) + "\n\n"
    impl_content += generate_int32_setter(properties) + "\n\n"
    impl_content += generate_double_setter(properties) + "\n\n"
    impl_content += generate_float_array_setter(properties) + "\n\n"
    
    # Add the global variable definitions at the top of the implementation file with proper header
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    impl_content = f"""/**
 * @file core_properties.c
 * @brief Auto-generated property implementation for SAGE model
 *
 * This file is automatically generated from properties.yaml by
 * generate_property_headers.py. DO NOT EDIT DIRECTLY.
 *
 * Generated on: {timestamp}
 */

/* Global variables for property system */
#include <stdint.h>
#include \"core_property_descriptor.h\"
#include \"core_properties.h\"

property_meta_t PROPERTY_META[PROP_COUNT];
const int32_t TotGalaxyProperties = PROP_COUNT;
const int32_t CORE_PROP_COUNT = {core_property_count}; /* Number of core properties, dynamically determined from properties.yaml */
const GalaxyPropertyInfo galaxy_property_info[PROP_COUNT] = {{
{galaxy_property_info_entries}
}};

""" + impl_content
    
    # Write the implementation file
    with open(output_path, "w") as f:
        f.write(impl_content)
    
    print(f"Generated {output_path}")

# =====================================================
# PARAMETER SYSTEM GENERATION
# =====================================================

PARAMETER_HEADER_TEMPLATE = """/**
 * @file {header_filename}
 * @brief Auto-generated parameter definitions for SAGE model
 *
 * This file is automatically generated from parameters.yaml by
 * generate_property_headers.py. DO NOT EDIT DIRECTLY.
 *
 * Generated on: {timestamp}
 */

#ifndef {include_guard}
#define {include_guard}

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

/* Forward declarations */
struct params;

/**
 * @brief Parameter ID enumeration used by core system
 */
typedef enum {{
{parameter_id_enum}
    PARAM_COUNT  /* Total number of parameters */
}} parameter_id_t;

/**
 * @brief Parameter metadata structure
 */
typedef struct {{
    const char *name;
    const char *type;
    const char *description;
    const char *category;
    bool required;
    bool has_bounds;
    union {{
        struct {{ int min; int max; }} int_bounds;
        struct {{ double min; double max; }} double_bounds;
    }} bounds;
    const char *struct_field;
}} parameter_meta_t;

/* Metadata array (accessible by parameter_id_t) */
extern parameter_meta_t PARAMETER_META[PARAM_COUNT];

/* Parameter system functions */

/**
 * @brief Initialize the parameter system
 * @param params Pointer to runtime parameters
 * @return 0 on success, non-zero on failure
 */
int initialize_parameter_system(struct params *params);

/**
 * @brief Clean up the parameter system resources
 */
void cleanup_parameter_system(void);

/**
 * @brief Set parameter from string value with validation
 * @param params Pointer to runtime parameters
 * @param param_id Parameter ID to set
 * @param value String value to parse and set
 * @return 0 on success, non-zero on failure
 */
int set_parameter_from_string(struct params *params, parameter_id_t param_id, const char *value);

/**
 * @brief Get parameter name string for a parameter ID
 * @param id Parameter ID
 * @return Parameter name string or NULL if ID is invalid
 */
const char* get_parameter_name(parameter_id_t id);

/**
 * @brief Get parameter ID for a parameter name
 * @param name Parameter name string
 * @return Parameter ID or PARAM_COUNT if not found
 */
parameter_id_t get_parameter_id(const char *name);

/**
 * @brief Check if parameter is required
 * @param id Parameter ID
 * @return true if required, false otherwise
 */
bool is_parameter_required(parameter_id_t id);

/**
 * @brief Check if parameter is core or physics category
 * @param id Parameter ID
 * @return true if core parameter, false if physics
 */
bool is_core_parameter(parameter_id_t id);

/* Type-safe parameter accessors */
{parameter_accessor_functions}

#endif /* {include_guard} */
"""

PARAMETER_IMPL_TEMPLATE = """/**
 * @file {impl_filename}
 * @brief Auto-generated parameter implementation for SAGE model
 *
 * This file is automatically generated from parameters.yaml by
 * generate_property_headers.py. DO NOT EDIT DIRECTLY.
 *
 * Generated on: {timestamp}
 */

#include "core_allvars.h"
#include "core_parameters.h"
#include "core_logging.h"
#include <string.h>
#include <stdlib.h>
#include <assert.h>

/* Parameter metadata array */
parameter_meta_t PARAMETER_META[PARAM_COUNT] = {{
{parameter_meta_entries}
}};

/**
 * @brief Initialize the parameter system
 * @param params Pointer to runtime parameters
 * @return 0 on success, non-zero on failure
 */
int initialize_parameter_system(struct params *params)
{{
    LOG_DEBUG("Initializing parameter system with %d parameters", PARAM_COUNT);
    
    if (params == NULL) {{
        LOG_ERROR("Params pointer is NULL during parameter system initialization");
        return -1;
    }}
    
    /* Initialize all parameters to default values */
{initialize_defaults_code}
    
    return 0;
}}

/**
 * @brief Clean up the parameter system resources
 */
void cleanup_parameter_system(void)
{{
    LOG_DEBUG("Cleaning up parameter system");
    /* Nothing to clean up for parameters at this time */
}}

/**
 * @brief Set parameter from string value with validation
 * @param params Pointer to runtime parameters
 * @param param_id Parameter ID to set
 * @param value String value to parse and set
 * @return 0 on success, non-zero on failure
 */
int set_parameter_from_string(struct params *params, parameter_id_t param_id, const char *value)
{{
    if (params == NULL || value == NULL) {{
        LOG_ERROR("NULL parameter pointer or value in set_parameter_from_string");
        return -1;
    }}
    
    if (param_id >= PARAM_COUNT) {{
        LOG_ERROR("Invalid parameter ID %d (max: %d)", param_id, PARAM_COUNT - 1);
        return -1;
    }}
    
    /* Interval-based debug logging (first 5 parameters only) */
    static int debug_count_params = 0;
    debug_count_params++;
    if (debug_count_params <= 5) {{
        if (debug_count_params == 5) {{
            LOG_DEBUG("Setting parameter %s = %s (further messages suppressed)", PARAMETER_META[param_id].name, value);
        }} else {{
            LOG_DEBUG("Setting parameter %s = %s", PARAMETER_META[param_id].name, value);
        }}
    }}
    
    /* Parse and set parameter based on type and validate bounds */
    switch (param_id) {{
{parameter_setters_code}
        default:
            LOG_ERROR("Unhandled parameter ID %d in set_parameter_from_string", param_id);
            return -1;
    }}
    
    return 0;
}}

/**
 * @brief Get parameter name string for a parameter ID
 */
const char* get_parameter_name(parameter_id_t id)
{{
    if (id >= 0 && id < PARAM_COUNT) {{
        return PARAMETER_META[id].name;
    }}
    return NULL;
}}

/**
 * @brief Get parameter ID for a parameter name
 */
parameter_id_t get_parameter_id(const char *name)
{{
    if (name == NULL) {{
        return PARAM_COUNT;
    }}
    
    for (int i = 0; i < PARAM_COUNT; i++) {{
        if (strcmp(PARAMETER_META[i].name, name) == 0) {{
            return (parameter_id_t)i;
        }}
    }}
    
    return PARAM_COUNT;
}}

/**
 * @brief Check if parameter is required
 */
bool is_parameter_required(parameter_id_t id)
{{
    if (id >= 0 && id < PARAM_COUNT) {{
        return PARAMETER_META[id].required;
    }}
    return false;
}}

/**
 * @brief Check if parameter is core or physics category
 */
bool is_core_parameter(parameter_id_t id)
{{
    if (id >= 0 && id < PARAM_COUNT) {{
        return strcmp(PARAMETER_META[id].category, "core") == 0;
    }}
    return false;
}}

/* Type-safe parameter accessors */
{parameter_accessor_implementations}
"""

def flatten_parameters(param_data):
    """Flatten the hierarchical parameter structure from YAML into a flat list"""
    flat_params = []
    
    if 'parameters' not in param_data:
        return flat_params
    
    categories = param_data['parameters']
    
    for category_name, subcategories in categories.items():
        for subcategory_name, params in subcategories.items():
            for param in params:
                # Add category information to parameter
                param['category'] = category_name
                param['subcategory'] = subcategory_name
                flat_params.append(param)
    
    return flat_params

def generate_parameter_id_enum(parameters):
    """Generate parameter ID enumeration from parameters list"""
    enum_lines = []
    for param in parameters:
        # Convert parameter name to valid C identifier
        param_name = param['name'].replace('-', '_').replace('.', '_').upper()
        enum_lines.append(f"    PARAM_{param_name},")
    return "\n".join(enum_lines)

def generate_parameter_meta_entries(parameters):
    """Generate parameter metadata array entries"""
    meta_entries = []
    
    for i, param in enumerate(parameters):
        # Extract bounds information
        has_bounds = 'bounds' in param
        bounds_code = "false, {{0}}"
        
        if has_bounds:
            bounds = param['bounds']
            param_type = param['type']
            if param_type in ['int']:
                bounds_code = f"true, {{.int_bounds = {{{bounds[0]}, {bounds[1]}}}}}"
            elif param_type in ['double']:
                bounds_code = f"true, {{.double_bounds = {{{bounds[0]}, {bounds[1]}}}}}"
            else:
                bounds_code = "false, {{0}}"
        
        # Format the entry
        entry = f"""    /* PARAM_{param['name'].replace('-', '_').replace('.', '_').upper()} */
    {{
        "{param['name']}",
        "{param['type']}",
        "{param.get('description', '')}",
        "{param['category']}",
        {str(param.get('required', False)).lower()},
        {bounds_code},
        "{param.get('struct_field', '')}"
    }}"""
        
        # Add comma if not the last entry
        if i < len(parameters) - 1:
            entry += ","
            
        meta_entries.append(entry)
    
    return "\n".join(meta_entries)

def generate_parameter_accessor_functions(parameters):
    """Generate accessor function declarations"""
    functions = []
    
    # Group parameters by type
    type_groups = {}
    for param in parameters:
        param_type = param['type']
        if param_type not in type_groups:
            type_groups[param_type] = []
        type_groups[param_type].append(param)
    
    # Generate accessor functions for each type
    for param_type, params in type_groups.items():
        if param_type == 'string':
            c_type = "const char*"
            default_val = "NULL"
        elif param_type == 'int':
            c_type = "int"
            default_val = "0"
        elif param_type == 'double':
            c_type = "double"
            default_val = "0.0"
        else:
            continue
        
        functions.append(f"""
/**
 * @brief Get {param_type} parameter value
 * @param params Pointer to runtime parameters
 * @param param_id Parameter ID
 * @param default_val Default value if parameter not found
 * @return Parameter value or default_val
 */
{c_type} get_{param_type}_parameter(const struct params *params, parameter_id_t param_id, {c_type} default_val);""")
    
    return "\n".join(functions)

def generate_parameter_accessor_implementations(parameters):
    """Generate accessor function implementations"""
    implementations = []
    
    # Group parameters by type
    type_groups = {}
    for param in parameters:
        param_type = param['type']
        if param_type not in type_groups:
            type_groups[param_type] = []
        type_groups[param_type].append(param)
    
    # Generate accessor functions for each type
    for param_type, params_of_type in type_groups.items():
        if param_type == 'string':
            c_type = "const char*"
            return_stmt = "return (const char*)"
        elif param_type == 'int':
            c_type = "int"
            return_stmt = "return"
        elif param_type == 'double':
            c_type = "double"
            return_stmt = "return"
        else:
            continue
        
        impl = f"""
{c_type} get_{param_type}_parameter(const struct params *params, parameter_id_t param_id, {c_type} default_val)
{{
    if (params == NULL || param_id >= PARAM_COUNT) {{
        return default_val;
    }}
    
    switch (param_id) {{"""
        
        # Add cases for each parameter of this type
        for param in params_of_type:
            param_name = param['name'].replace('-', '_').replace('.', '_').upper()
            struct_field = param.get('struct_field', '')
            if struct_field:
                # Check if this is an enum parameter requiring special handling
                if param_type == 'string' and param.get('enum_type', False) and param.get('enum_values'):
                    # Generate enum-to-string conversion
                    impl += f"""
        case PARAM_{param_name}:
            /* Convert enum to string representation */
            switch (params->{struct_field}) {{"""
                    for enum_val in param['enum_values']:
                        impl += f"""
                case {enum_val}: return "{enum_val}";"""
                    impl += f"""
                default: return default_val;
            }}"""
                else:
                    # Regular field access
                    impl += f"""
        case PARAM_{param_name}:
            {return_stmt} params->{struct_field};"""
        
        impl += f"""
        default:
            return default_val;
    }}
}}"""
        
        implementations.append(impl)
    
    return "\n".join(implementations)

def generate_initialize_defaults_code(parameters):
    """Generate code to initialize parameters to default values"""
    code_lines = []
    
    for param in parameters:
        default_value = param.get('default_value')
        struct_field = param.get('struct_field', '')
        
        if default_value is not None and struct_field:
            param_type = param['type']
            if param_type == 'string':
                code_lines.append(f'    strncpy(params->{struct_field}, "{default_value}", MAX_STRING_LEN-1);')
                code_lines.append(f'    params->{struct_field}[MAX_STRING_LEN-1] = \'\\0\';')
            elif param_type in ['int', 'double']:
                code_lines.append(f'    params->{struct_field} = {default_value};')
    
    return "\n".join(code_lines)

def generate_parameter_setters_code(parameters):
    """Generate parameter setter code for the switch statement"""
    setters = []
    
    for param in parameters:
        param_name = param['name'].replace('-', '_').replace('.', '_').upper()
        param_type = param['type']
        struct_field = param.get('struct_field', '')
        
        if not struct_field:
            continue
            
        setter = f"""        case PARAM_{param_name}: {{"""
        
        # Add bounds checking if present
        if 'bounds' in param:
            bounds = param['bounds']
            if param_type == 'int':
                setter += f"""
            int int_val = atoi(value);
            if (int_val < {bounds[0]} || int_val > {bounds[1]}) {{
                LOG_ERROR("Parameter {param['name']} value %d out of bounds [%d, %d]", int_val, {bounds[0]}, {bounds[1]});
                return -1;
            }}
            params->{struct_field} = int_val;"""
            elif param_type == 'double':
                setter += f"""
            double double_val = atof(value);
            if (double_val < {bounds[0]} || double_val > {bounds[1]}) {{
                LOG_ERROR("Parameter {param['name']} value %f out of bounds [%f, %f]", double_val, {bounds[0]}, {bounds[1]});
                return -1;
            }}
            params->{struct_field} = double_val;"""
        else:
            # No bounds checking
            if param_type == 'int':
                setter += f"""
            params->{struct_field} = atoi(value);"""
            elif param_type == 'double':
                setter += f"""
            params->{struct_field} = atof(value);"""
            elif param_type == 'string':
                # Check if this is an enum type
                if param.get('enum_type', False):
                    enum_values = param.get('enum_values', [])
                    setter += f"""
            /* This is an enum parameter - convert string to enum value */
            int found = 0;"""
                    for i, enum_val in enumerate(enum_values):
                        if 'TreeType' in struct_field:
                            setter += f"""
            if (strcasecmp(value, "{enum_val}") == 0) {{
                params->{struct_field} = {enum_val};
                found = 1;
            }}"""
                        elif 'ForestDistributionScheme' in struct_field:
                            setter += f"""
            if (strcasecmp(value, "{enum_val}") == 0) {{
                params->{struct_field} = {enum_val};
                found = 1;
            }}"""
                    setter += f"""
            if (!found) {{
                LOG_ERROR("Invalid value '%s' for parameter {param['name']}", value);
                return -1;
            }}"""
                else:
                    # Regular string parameter
                    setter += f"""
            strncpy(params->{struct_field}, value, MAX_STRING_LEN-1);
            params->{struct_field}[MAX_STRING_LEN-1] = '\\0';"""
        
        setter += """
            break;
        }"""
        
        setters.append(setter)
    
    return "\n".join(setters)

def generate_parameter_header_file(parameters, output_dir=""):
    """Generate the parameter header file"""
    header_filename = "core_parameters.h"
    output_path = os.path.join(output_dir, header_filename)
    
    # Generate header components
    include_guard = sanitize_include_guard(header_filename)
    parameter_id_enum = generate_parameter_id_enum(parameters)
    parameter_accessor_functions = generate_parameter_accessor_functions(parameters)
    
    # Fill in the template
    header_content = PARAMETER_HEADER_TEMPLATE.format(
        header_filename=header_filename,
        include_guard=include_guard,
        timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        parameter_id_enum=parameter_id_enum,
        parameter_accessor_functions=parameter_accessor_functions
    )
    
    # Write the header file
    with open(output_path, "w") as f:
        f.write(header_content)
    
    print(f"Generated {output_path}")

def generate_parameter_implementation_file(parameters, output_dir=""):
    """Generate the parameter implementation file"""
    impl_filename = "core_parameters.c"
    output_path = os.path.join(output_dir, impl_filename)
    
    # Generate implementation components
    parameter_meta_entries = generate_parameter_meta_entries(parameters)
    initialize_defaults_code = generate_initialize_defaults_code(parameters)
    parameter_setters_code = generate_parameter_setters_code(parameters)
    parameter_accessor_implementations = generate_parameter_accessor_implementations(parameters)
    
    # Fill in the template
    impl_content = PARAMETER_IMPL_TEMPLATE.format(
        impl_filename=impl_filename,
        timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        parameter_meta_entries=parameter_meta_entries,
        initialize_defaults_code=initialize_defaults_code,
        parameter_setters_code=parameter_setters_code,
        parameter_accessor_implementations=parameter_accessor_implementations
    )
    
    # Write the implementation file
    with open(output_path, "w") as f:
        f.write(impl_content)
    
    print(f"Generated {output_path}")

def load_fetch_numoutputs_placeholder():
    """Create a placeholder function to fetch NumSnapOutputs for dynamic arrays"""
    code = """
/**
 * @brief Fetch NumSnapOutputs parameter for sizing dynamic arrays
 * This is a temporary placeholder for the full parameter system integration
 * @return Number of snapshot outputs or a default value
 */
int fetch_NumSnapOutputs(void) {
    extern struct params Params;  /* From core_allvars.h */
    return Params.simulation.NumSnapOutputs;
}
"""
    return code

def main():
    """Main entry point for the script"""
    # Parse command line arguments
    import argparse
    parser = argparse.ArgumentParser(description='Generate property and parameter headers from YAML definitions with module-aware filtering')
    parser.add_argument('--input', default='properties.yaml', help='Input YAML file (default: properties.yaml)')
    parser.add_argument('--parameters', default='parameters.yaml', help='Input parameter YAML file (default: parameters.yaml)')
    parser.add_argument('--config', help='JSON configuration file to determine active modules')
    parser.add_argument('--modules', help='Comma-separated list of active modules (alternative to --config)')
    parser.add_argument('--core-only', action='store_true', help='Generate only core properties (physics-free mode)')
    parser.add_argument('--all-properties', action='store_true', help='Generate all properties (ignore any config files)')
    parser.add_argument('--generate-parameters', action='store_true', help='Also generate parameter system files')
    args = parser.parse_args()
    
    # Determine file paths
    script_dir = os.path.dirname(os.path.abspath(__file__))
    yaml_file = os.path.join(script_dir, args.input)
    parameters_file = os.path.join(script_dir, args.parameters)
    core_dir = os.path.join(script_dir, "core")
    
    # Check if input file exists
    if not os.path.exists(yaml_file):
        print(f"Error: Could not find {args.input} at {yaml_file}")
        sys.exit(1)
        
    # Check if parameter file exists when requested
    if args.generate_parameters and not os.path.exists(parameters_file):
        print(f"Error: Could not find {args.parameters} at {parameters_file}")
        sys.exit(1)
    
    try:
        # Load properties from YAML
        with open(yaml_file, "r") as f:
            data = yaml.safe_load(f)
            properties = data.get("properties", [])
        
        if not properties:
            print(f"Error: No properties found in {args.input}")
            sys.exit(1)
        
        # Determine active modules
        active_modules = []
        if args.core_only:
            print("Generating core-only properties (physics-free mode)")
            active_modules = []
        elif args.all_properties:
            print("Generating all properties (full-physics mode)")
            active_modules = None  # None means include all properties
        elif args.modules:
            active_modules = [m.strip() for m in args.modules.split(',')]
            print(f"Generating properties for modules: {', '.join(active_modules)}")
        elif args.config:
            # Validate config file exists before processing
            if not os.path.exists(args.config):
                print(f"Error: Configuration file '{args.config}' not found")
                sys.exit(1)
            active_modules = get_active_modules_from_config(args.config)
            print(f"Generating properties for modules from config: {', '.join(active_modules)}")
        else:
            # Check for default config file to determine behavior
            default_config_paths = [
                os.path.join(script_dir, "..", "input", "default_config.json"),
                os.path.join(script_dir, "..", "input", "config.json")
            ]
            
            default_config = None
            for config_path in default_config_paths:
                if os.path.exists(config_path):
                    default_config = config_path
                    break
            
            if default_config:
                active_modules = get_active_modules_from_config(default_config)
                if not active_modules:
                    print(f"Found default config with no modules: {default_config} - generating core-only properties")
                else:
                    print(f"Found default config: {default_config} - generating properties for modules: {', '.join(active_modules)}")
            else:
                print("No configuration found - generating all properties (backward compatibility)")
                # Generate all properties (backward compatibility)
                active_modules = None
        
        # Filter properties based on active modules
        if active_modules is not None:
            filtered_properties = filter_properties_by_modules(properties, active_modules)
            print(f"Filtered {len(properties)} properties to {len(filtered_properties)} (core + module-specific)")
            properties = filtered_properties
        
        # Generate the header and implementation files
        generate_header_file(properties, core_dir)
        generate_implementation_file(properties, core_dir)
        
        # Generate the output transformers file
        generate_transformers_file(properties, core_dir)
        
        print("Property header generation complete!")
        
        # Generate parameter system files if requested
        if args.generate_parameters:
            print("\nGenerating parameter system files...")
            
            # Load parameters from YAML
            with open(parameters_file, "r") as f:
                param_data = yaml.safe_load(f)
            
            # Flatten the hierarchical parameter structure
            parameters = flatten_parameters(param_data)
            
            if not parameters:
                print(f"Warning: No parameters found in {args.parameters}")
            else:
                print(f"Found {len(parameters)} parameters in {args.parameters}")
                
                # Generate parameter header and implementation files
                generate_parameter_header_file(parameters, core_dir)
                generate_parameter_implementation_file(parameters, core_dir)
                
                print("Parameter system generation complete!")
        
    except Exception as e:
        print(f"Error generating headers: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()
