#!/usr/bin/env python3
# generate_property_headers.py
# SAGE Property Header Generator
# This script reads properties.yaml and generates C header files containing
# macros and functions to access galaxy properties, as well as output transformer
# dispatch code.

import os
import sys
import yaml
import re
from datetime import datetime

# Constants
HEADER_TEMPLATE = """/**
 * @file {header_filename}
 * @brief Auto-generated property definitions for SAGE model
 *
 * This file is automatically generated from properties.yaml by
 * generate_property_headers.py. DO NOT EDIT DIRECTLY.
 *
 * Generated on: {timestamp}
 */

#ifndef {include_guard}
#define {include_guard}

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include "macros.h" /* For STEPS definition */

/* HDF5 types needed for property transformer function signatures */
#ifdef HDF5
#include <hdf5.h>
#else
/* Minimal HDF5 type definitions when HDF5 is not available */
typedef int hid_t;
#define H5T_NATIVE_FLOAT 0
#define H5T_NATIVE_DOUBLE 1
#define H5T_NATIVE_INT 2
#define H5T_NATIVE_LLONG 3
#endif

/* Property types and metadata */

/**
 * @brief Property ID enumeration used by core system
 */
typedef enum {{
{property_id_enum}
    PROP_COUNT  /* Total number of properties */
}} property_id_t;

/* STEPS is already defined in macros.h - using that value for array dimensions */

/**
 * @brief Property metadata structure
 */
typedef struct {{
    const char *name;
    const char *type;
    const char *units;
    const char *description;
    bool output;
    int read_only;  /* 0=false, 1=true, 2=after_first_set */
    bool is_array;
    int array_dimension;
    const char *size_parameter;
}} property_meta_t;

/**
 * @brief Core galaxy property storage structure
 * This structure holds all the galaxy properties but is not
 * directly accessed. All access occurs through the generated macros.
 */
typedef struct {{
{property_struct_fields}
}} galaxy_properties_t;

/* Metadata array (accessible by property_id_t) */
extern property_meta_t PROPERTY_META[PROP_COUNT];

/* Forward declarations for property system */
struct GALAXY;
struct params;

/* Property system functions */

/**
 * @brief Initialize the property system
 * @param params Pointer to runtime parameters
 * @return 0 on success, non-zero on failure
 */
int initialize_property_system(const struct params *params);

/**
 * @brief Clean up the property system resources
 */
void cleanup_property_system(void);

/**
 * @brief Allocate property memory for a galaxy
 * @param g Galaxy pointer
 * @param params Pointer to runtime parameters
 * @return 0 on success, non-zero on failure
 */
int allocate_galaxy_properties(struct GALAXY *g, const struct params *params);

/**
 * @brief Free property memory for a galaxy
 * @param g Galaxy pointer
 */
void free_galaxy_properties(struct GALAXY *g);

/**
 * @brief Copy all properties from source galaxy to destination galaxy
 * @param dest Destination galaxy
 * @param src Source galaxy
 * @param params Pointer to runtime parameters
 * @return 0 on success, non-zero on failure
 */
int copy_galaxy_properties(struct GALAXY *dest, const struct GALAXY *src, const struct params *params);

/**
 * @brief Reset properties to initial values
 * @param g Galaxy pointer
 */
void reset_galaxy_properties(struct GALAXY *g);

/**
 * @brief Get property name string for a property ID
 * @param id Property ID
 * @return Property name string or NULL if ID is invalid
 */
const char* get_property_name(property_id_t id);

/**
 * @brief Get property ID for a property name
 * @param name Property name string
 * @return Property ID or PROP_COUNT if not found
 */
property_id_t get_property_id(const char *name);

/* Generated property dispatcher functions */
float get_generated_float(const galaxy_properties_t *props, property_id_t prop_id, float default_value);
int32_t get_generated_int32(const galaxy_properties_t *props, property_id_t prop_id, int32_t default_value);
double get_generated_double(const galaxy_properties_t *props, property_id_t prop_id, double default_value);

float get_generated_float_array_element(const galaxy_properties_t *props, property_id_t prop_id, int array_idx, float default_value);
int32_t get_generated_int32_array_element(const galaxy_properties_t *props, property_id_t prop_id, int array_idx, int32_t default_value);
double get_generated_double_array_element(const galaxy_properties_t *props, property_id_t prop_id, int array_idx, double default_value);

int get_generated_array_size(const galaxy_properties_t *props, property_id_t prop_id);

/* Generated property dispatcher functions - setters */
void set_generated_float(galaxy_properties_t *props, property_id_t prop_id, float value);
void set_generated_int32(galaxy_properties_t *props, property_id_t prop_id, int32_t value);
void set_generated_double(galaxy_properties_t *props, property_id_t prop_id, double value);

/* Output transformer dispatch function */
/**
 * @brief Dispatches to the appropriate output transformer or performs default identity transform.
 * @param galaxy The galaxy being processed.
 * @param output_prop_id Property ID of the field being written to HDF5.
 * @param output_prop_name Name of the field being written to HDF5.
 * @param output_buffer_element_ptr Pointer to the HDF5 buffer slot for this galaxy's property.
 * @param run_params Global run parameters.
 * @param h5_dtype HDF5 data type of the output field.
 * @return 0 on success, non-zero on error.
 */
int dispatch_property_transformer(const struct GALAXY *galaxy,
                                  property_id_t output_prop_id,
                                  const char *output_prop_name,
                                  void *output_buffer_element_ptr,
                                  const struct params *run_params,
                                  hid_t h5_dtype);

/* Property accessors */
{property_accessor_macros}

#endif /* {include_guard} */
"""

TRANSFORMERS_TEMPLATE = """/**
 * @file {transformers_filename}
 * @brief Auto-generated output transformer dispatch for SAGE model
 *
 * This file is automatically generated from properties.yaml by
 * generate_property_headers.py. DO NOT EDIT DIRECTLY.
 *
 * Generated on: {timestamp}
 */

#include "core_allvars.h"
#include "core_properties.h"
#include "core_property_utils.h"
#include "core_logging.h"
#include <string.h>

/* Extern declarations for all transformer functions */
{transformer_function_externs}

/**
 * @brief Dispatches to the appropriate output transformer or performs default identity transform.
 * @param galaxy The galaxy being processed.
 * @param output_prop_id Property ID of the field being written to HDF5.
 * @param output_prop_name Name of the field being written to HDF5.
 * @param output_buffer_element_ptr Pointer to the HDF5 buffer slot for this galaxy's property.
 * @param run_params Global run parameters.
 * @param h5_dtype HDF5 data type of the output field.
 * @return 0 on success, non-zero on error.
 */
int dispatch_property_transformer(const struct GALAXY *galaxy,
                                  property_id_t output_prop_id,
                                  const char *output_prop_name,
                                  void *output_buffer_element_ptr,
                                  const struct params *run_params,
                                  hid_t h5_dtype) {{
    int status = 0;
    
    // Auto-generated if/else if chain based on property name
{dispatcher_if_chain}
    else {{
        // Default identity transformation for properties without a transformer
        if (galaxy->properties == NULL) {{
            LOG_ERROR("Galaxy properties is NULL for property '%s'", output_prop_name);
            return -1;
        }}
        
        // This uses the output_prop_id to fetch the raw value
        if (h5_dtype == H5T_NATIVE_FLOAT) {{
            *((float*)output_buffer_element_ptr) = get_float_property(galaxy, output_prop_id, 0.0f);
        }} else if (h5_dtype == H5T_NATIVE_DOUBLE) {{
            *((double*)output_buffer_element_ptr) = get_double_property(galaxy, output_prop_id, 0.0);
        }} else if (h5_dtype == H5T_NATIVE_INT) {{
            *((int32_t*)output_buffer_element_ptr) = get_int32_property(galaxy, output_prop_id, 0);
        }} else if (h5_dtype == H5T_NATIVE_LLONG) {{
            // Assuming int64_t for H5T_NATIVE_LLONG output
            *((int64_t*)output_buffer_element_ptr) = get_int64_property(galaxy, output_prop_id, 0LL);
        }} else {{
            LOG_ERROR("Unsupported HDF5 type for default identity transform of property '%s'", output_prop_name);
            status = -1;
        }}
    }}
    
    return status;
}}
"""

IMPLEMENTATION_TEMPLATE = """/**
 * @file {impl_filename}
 * @brief Auto-generated property implementation for SAGE model
 *
 * This file is automatically generated from properties.yaml by
 * generate_property_headers.py. DO NOT EDIT DIRECTLY.
 *
 * Generated on: {timestamp}
 */

#include "core_allvars.h"
#include "core_properties.h"
#include "core_logging.h"
#include <string.h>
#include <stdlib.h>
#include <assert.h>

/* Property metadata array */
property_meta_t PROPERTY_META[PROP_COUNT] = {{
{property_meta_entries}
}};

/* Parameter resolution function for dynamic arrays */
{resolve_parameter_function}

/**
 * @brief Initialize the property system
 * @param params Pointer to runtime parameters
 * @return 0 on success, non-zero on failure
 */
int initialize_property_system(const struct params *params)
{{
    LOG_DEBUG("Initializing property system with %d properties", PROP_COUNT);
    /* Validate sizes of dynamic arrays from parameters */
{initialize_property_system_code}
    return 0;
}}

/**
 * @brief Clean up the property system resources
 */
void cleanup_property_system(void)
{{
    LOG_DEBUG("Cleaning up property system");
    /* Cleanup any allocated memory for the property system */
}}

/**
 * @brief Allocate property memory for a galaxy
 * @param g Galaxy pointer
 * @param params Pointer to runtime parameters
 * @return 0 on success, non-zero on failure
 */
int allocate_galaxy_properties(struct GALAXY *g, const struct params *params)
{{
    if (g == NULL) {{
        LOG_ERROR("Cannot allocate properties for NULL galaxy pointer");
        return -1;
    }}
    
    /* Allocate the property structure */
    g->properties = (galaxy_properties_t *)calloc(1, sizeof(galaxy_properties_t));
    if (g->properties == NULL) {{
        LOG_ERROR("Failed to allocate galaxy properties structure");
        return -1;
    }}
    
    /* Allocate memory for dynamic arrays */
{allocate_dynamic_arrays_code}
    
    return 0;
}}

/**
 * @brief Free property memory for a galaxy
 */
void free_galaxy_properties(struct GALAXY *g)
{{
    if (g == NULL || g->properties == NULL) {{
        return;
    }}
    
    /* Free dynamic arrays */
{free_dynamic_arrays_code}
    
    /* Free the property structure itself */
    free(g->properties);
    g->properties = NULL;
}}

/**
 * @brief Copy all properties from source galaxy to destination galaxy
 * @param dest Destination galaxy
 * @param src Source galaxy
 * @param params Pointer to runtime parameters
 * @return 0 on success, non-zero on failure
 */
int copy_galaxy_properties(struct GALAXY *dest, const struct GALAXY *src, const struct params *params)
{{
    if (dest == NULL || src == NULL) {{
        LOG_ERROR("NULL galaxy pointer in property copy");
        return -1;
    }}
    
    /* Free existing destination properties if present */
    free_galaxy_properties(dest);
    
    /* Allocate new properties */
    if (allocate_galaxy_properties(dest, params) != 0) {{
        return -1;
    }}
    
    /* Copy fixed-size fields */
{copy_fixed_fields_code}

    /* Copy dynamic arrays */
{copy_dynamic_arrays_code}
    
    return 0;
}}

/**
 * @brief Reset properties to initial values
 */
void reset_galaxy_properties(struct GALAXY *g)
{{
    if (g == NULL || g->properties == NULL) {{
        LOG_ERROR("Cannot reset properties for NULL galaxy or property pointer");
        return;
    }}
    
    /* Reset fixed properties to initial values */
{reset_property_values_code}
}}

/**
 * @brief Get property name string for a property ID
 */
const char* get_property_name(property_id_t id)
{{
    if (id >= 0 && id < PROP_COUNT) {{
        return PROPERTY_META[id].name;
    }}
    return NULL;
}}

/**
 * @brief Get property ID for a property name
 */
property_id_t get_property_id(const char *name)
{{
    if (name == NULL) {{
        return PROP_COUNT;
    }}
    
    for (int i = 0; i < PROP_COUNT; i++) {{
        if (strcmp(PROPERTY_META[i].name, name) == 0) {{
            return (property_id_t)i;
        }}
    }}
    
    return PROP_COUNT;
}}

/* Additional helper functions for property system */
{additional_helper_functions}
"""

# C type mapping
C_TYPE_MAP = {
    "int": "int",
    "int32_t": "int32_t",
    "uint32_t": "uint32_t",
    "int64_t": "int64_t",
    "uint64_t": "uint64_t",
    "long long": "long long",
    "float": "float",
    "double": "double",
    "bool": "bool",
    "char": "char",
}

def sanitize_include_guard(filename):
    """Convert a filename to a valid C include guard name"""
    base = os.path.basename(filename)
    base = os.path.splitext(base)[0].upper()
    return f"{base}_H"

def parse_type(type_str):
    """Parse a type string and determine base type, array dimensions, and if it's dynamic"""
    is_array = False
    array_dim = 0
    is_dynamic = False
    base_type = type_str
    size_spec = ""
    
    # Check for array syntax: type[size] or type[]
    array_match = re.match(r'(\w+)(?:\[(\w*)\])+', type_str)
    if array_match:
        is_array = True
        base_type = array_match.group(1)
        size_spec = array_match.group(2)
        
        if size_spec == "":
            # Dynamic array: type[]
            is_dynamic = True
        else:
            # Fixed array: type[SIZE]
            array_dim = size_spec
    
    return base_type, is_array, array_dim, is_dynamic, size_spec

def generate_property_id_enum(properties):
    """Generate property ID enumeration from properties list"""
    enum_lines = []
    for prop in properties:
        enum_lines.append(f"    PROP_{prop['name']},")
    return "\n".join(enum_lines)

def generate_property_struct_fields(properties):
    """Generate struct fields for the galaxy_properties_t structure"""
    fields = []
    
    for prop in properties:
        # Get type information
        type_str = prop['type']
        base_type, is_array, array_dim, is_dynamic, size_spec = parse_type(type_str)
        
        # Generate field declarations
        if is_array:
            if is_dynamic:
                # Dynamic array with size field
                fields.append(f"    {base_type} *{prop['name']};")
                fields.append(f"    int {prop['name']}_size;")
            else:
                # Fixed-size array
                fields.append(f"    {base_type} {prop['name']}[{array_dim}];")
        else:
            # Simple scalar field
            fields.append(f"    {base_type} {prop['name']};")
    
    return "\n".join(fields)

def generate_property_accessor_macros(properties):
    """Generate accessor macros for all properties"""
    macros = []
    
    # Add the safe array access macro at the beginning
    macros.append("""/**
 * @brief Safely access an element of a galaxy property array with bounds checking.
 * @param g Pointer to the GALAXY struct.
 * @param prop_base_name The base name of the property (e.g., StarFormationHistory).
 * @param idx The index to access.
 * @param default_val The value to return if the index is out of bounds.
 * @return The array element value or default_val on error.
 */
#define GALAXY_PROP_ARRAY_SAFE(g, prop_base_name, idx, default_val) \\
    (((idx) >= 0 && (idx) < (g)->properties->prop_base_name##_size) ? \\
     ((g)->properties->prop_base_name[idx]) : \\
     (LOG_ERROR("Array index out of bounds: %s[%d] (size: %d)", #prop_base_name, (idx), (g)->properties->prop_base_name##_size), (default_val)))
""")
    
    for prop in properties:
        # Get type information
        type_str = prop['type']
        base_type, is_array, array_dim, is_dynamic, size_spec = parse_type(type_str)
        
        read_only = prop.get('read_only', False)
        read_only_comment = ""
        if read_only and read_only != "false":
            read_only_comment = " /* Read-only" + (" after first set" if read_only == "after_first_set" else "") + " */"
            
        # Generate accessor macro
        macros.append(f"#define GALAXY_PROP_{prop['name']}(g) ((g)->properties->{prop['name']}){read_only_comment}")
        
        # Add element accessor for arrays
        if is_array:
            if is_dynamic:
                # Add size accessor for dynamic arrays
                macros.append(f"#define GALAXY_PROP_{prop['name']}_SIZE(g) ((g)->properties->{prop['name']}_size)")
            
            # Element accessor works for both fixed and dynamic arrays
            macros.append(f"#define GALAXY_PROP_{prop['name']}_ELEM(g, idx) ((g)->properties->{prop['name']}[idx])")
            
            # For dynamic arrays, add a size setter function declaration
            if is_dynamic:
                macros.append(f"\nint galaxy_set_{prop['name']}_size(struct GALAXY *g, int size);")
                
        macros.append("")  # Add blank line between property accessors
    
    return "\n".join(macros)

def generate_property_meta_entries(properties):
    """Generate property metadata array entries"""
    meta_entries = []
    
    for i, prop in enumerate(properties):
        # Get type information
        type_str = prop['type']
        base_type, is_array, array_dim, is_dynamic, size_spec = parse_type(type_str)
        
        # Convert read_only to int value (0=false, 1=true, 2=after_first_set)
        read_only = prop.get('read_only', False)
        read_only_val = 0
        if read_only == True or read_only == "true":
            read_only_val = 1
        elif read_only == "after_first_set":
            read_only_val = 2
            
        # Size parameter for dynamic arrays
        size_param = "NULL"
        if is_dynamic and 'size_parameter' in prop:
            size_param = f'"{prop["size_parameter"]}"'
        
        # Format the entry
        entry = f"""    /* PROP_{prop['name']} */
    {{
        "{prop['name']}",
        "{type_str}",
        "{prop.get('units', 'dimensionless')}",
        "{prop.get('description', '')}",
        {str(prop.get('output', True)).lower()},
        {read_only_val},
        {str(is_array).lower()},
        {array_dim if array_dim else 0},
        {size_param}
    }}"""
        
        # Add comma if not the last entry
        if i < len(properties) - 1:
            entry += ","
            
        meta_entries.append(entry)
    
    return "\n".join(meta_entries)

def generate_transformer_externs(properties):
    """Generate extern declarations for transformer functions"""
    externs = []
    transformer_funcs = set()
    
    for prop in properties:
        if 'output_transformer_function' in prop:
            func_name = prop['output_transformer_function']
            if func_name not in transformer_funcs:
                transformer_funcs.add(func_name)
                externs.append(f"extern int {func_name}(const struct GALAXY *galaxy, property_id_t output_prop_id, "
                              f"void *output_buffer_element_ptr, const struct params *run_params);")
    
    return "\n".join(externs)

def generate_transformer_dispatch_chain(properties):
    """Generate if/else chain for the dispatcher function"""
    chains = []
    
    for prop in properties:
        if 'output_transformer_function' in prop:
            func_name = prop['output_transformer_function']
            chains.append(f"""    if (strcmp(output_prop_name, "{prop['name']}") == 0) {{
        status = {func_name}(galaxy, output_prop_id, output_buffer_element_ptr, run_params);
    }}""")
    
    # Join with "else" for all entries except the last one
    if chains:
        for i in range(1, len(chains)):
            chains[i] = "else " + chains[i]
    
    return "\n".join(chains)

def generate_transformers_file(properties, output_dir=""):
    """Generate the output transformers file"""
    transformers_filename = "generated_output_transformers.c"
    output_path = os.path.join(output_dir, transformers_filename)
    
    # Generate components
    transformer_function_externs = generate_transformer_externs(properties)
    dispatcher_if_chain = generate_transformer_dispatch_chain(properties)
    
    # Fill in the template
    transformers_content = TRANSFORMERS_TEMPLATE.format(
        transformers_filename=transformers_filename,
        timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        transformer_function_externs=transformer_function_externs,
        dispatcher_if_chain=dispatcher_if_chain
    )
    
    # Write the output transformers file
    with open(output_path, "w") as f:
        f.write(transformers_content)
    
    print(f"Generated {output_path}")

def generate_initialize_code(properties):
    """Generate code for initializing the property system"""
    code_lines = []
    
    code_lines.append("    if (params == NULL) {")
    code_lines.append("        LOG_ERROR(\"Params pointer is NULL during property system initialization.\");")
    code_lines.append("        return -1;")
    code_lines.append("    }")
    code_lines.append("    LOG_DEBUG(\"Validating dynamic array size parameters...\");")
    code_lines.append("    for (int i = 0; i < PROP_COUNT; i++) {")
    code_lines.append("        if (PROPERTY_META[i].is_array && PROPERTY_META[i].array_dimension == 0 &&")
    code_lines.append("            PROPERTY_META[i].size_parameter != NULL) {")
    code_lines.append("            int size = resolve_parameter_value(PROPERTY_META[i].size_parameter, params);")
    code_lines.append("            if (size < 0) {") # Check for negative size (error from resolve)
    code_lines.append("                LOG_ERROR(\"Failed to resolve or invalid size parameter '%s' for dynamic array '%s'\",")
    code_lines.append("                         PROPERTY_META[i].size_parameter, PROPERTY_META[i].name);")
    code_lines.append("                return -1; // Fail initialization")
    code_lines.append("            }")
    code_lines.append("            LOG_DEBUG(\"Validated size parameter '%s' for dynamic array '%s' (resolved size: %d)\",")
    code_lines.append("                       PROPERTY_META[i].size_parameter, PROPERTY_META[i].name, size);")
    code_lines.append("        }")
    code_lines.append("    }")
    
    return "\n".join(code_lines)

def generate_allocate_arrays_code(properties):
    """Generate code for allocating dynamic arrays"""
    code_lines = []
    
    # Find properties with dynamic arrays
    dynamic_arrays = [p for p in properties if parse_type(p['type'])[3]]
    if dynamic_arrays:
        for prop in dynamic_arrays:
            base_type = parse_type(prop['type'])[0]
            code_lines.extend([
                f"    /* Allocate {prop['name']} array */",
                f"    if (PROPERTY_META[PROP_{prop['name']}].size_parameter != NULL) {{",
                f"        // Get size from parameters",
                f"        int resolved_size = resolve_parameter_value(PROPERTY_META[PROP_{prop['name']}].size_parameter, params);",
                f"        if (resolved_size < 0) {{",
                f"            LOG_ERROR(\"Failed to resolve size for dynamic array '{prop['name']}' during allocation\");",
                f"            free_galaxy_properties(g); // Cleanup partially allocated",
                f"            return -1;",
                f"        }}",
                f"        // Call the specific generated size setter",
                f"        int status = galaxy_set_{prop['name']}_size(g, resolved_size);",
                f"        if (status != 0) {{",
                f"            LOG_ERROR(\"Failed to set size and allocate for dynamic array '{prop['name']}'\");",
                f"            free_galaxy_properties(g); // Cleanup partially allocated",
                f"            return -1;",
                f"        }}",
                f"        LOG_DEBUG(\"Allocated dynamic array '{prop['name']}' with size %d\", resolved_size);",
                f"    }}"
            ])
    
    return "\n".join(code_lines)

def generate_free_arrays_code(properties):
    """Generate code for freeing dynamic arrays"""
    code_lines = []
    
    # Find properties with dynamic arrays
    dynamic_arrays = [p for p in properties if parse_type(p['type'])[3]]
    if dynamic_arrays:
        for prop in dynamic_arrays:
            code_lines.extend([
                f"    /* Free {prop['name']} array */",
                f"    if (g->properties->{prop['name']} != NULL) {{",
                f"        free(g->properties->{prop['name']});",
                f"        g->properties->{prop['name']} = NULL;",
                f"        g->properties->{prop['name']}_size = 0;",
                f"    }}"
            ])
    
    return "\n".join(code_lines)

def generate_copy_fixed_fields_code(properties):
    """Generate code for copying fixed-size fields"""
    return """    /* Copy the basic structure */
    memcpy(dest->properties, src->properties, sizeof(galaxy_properties_t));

    /* Reset dynamic array pointers to NULL to avoid double-free issues */""" + '\n'.join([
        f"    dest->properties->{p['name']} = NULL;" 
        for p in properties if parse_type(p['type'])[3]
    ])

def generate_copy_dynamic_arrays_code(properties):
    """Generate code for copying dynamic arrays"""
    code_lines = []
    
    # Find properties with dynamic arrays
    dynamic_arrays = [p for p in properties if parse_type(p['type'])[3]]
    if dynamic_arrays:
        for prop in dynamic_arrays:
            base_type = parse_type(prop['type'])[0]
            code_lines.extend([
                f"    /* Copy {prop['name']} array */",
                f"    if (src->properties->{prop['name']} != NULL && src->properties->{prop['name']}_size > 0) {{",
                f"        int size = src->properties->{prop['name']}_size;",
                f"        dest->properties->{prop['name']} = ({base_type} *)malloc(size * sizeof({base_type}));",
                f"        if (dest->properties->{prop['name']} == NULL) {{",
                f"            LOG_ERROR(\"Failed to allocate memory for {prop['name']} property during copy\");",
                f"            return -1;",
                f"        }}",
                f"        dest->properties->{prop['name']}_size = size;",
                f"        memcpy(dest->properties->{prop['name']}, src->properties->{prop['name']}, size * sizeof({base_type}));",
                f"    }}",
            ])
    
    return "\n".join(code_lines)

def generate_reset_property_values_code(properties):
    """Generate code for resetting properties to initial values"""
    code_lines = []
    
    # Reset all properties to their initial values
    for prop in properties:
        type_str = prop['type']
        base_type, is_array, array_dim, is_dynamic, size_spec = parse_type(type_str)
        initial_value = prop.get('initial_value', 0)
        
        if is_array:
            if is_dynamic:
                # Dynamic arrays - don't reset, just leave as is
                continue
            
            if isinstance(initial_value, list):
                # List of initial values for array elements
                for i, val in enumerate(initial_value):
                    if i < int(array_dim):  # Only set values that fit in the array
                        code_lines.append(f"    g->properties->{prop['name']}[{i}] = {val}f;")
            else:
                # Single initial value for all elements
                code_lines.append(f"    for (int i = 0; i < {array_dim}; i++) {{")
                code_lines.append(f"        g->properties->{prop['name']}[i] = {initial_value}f;")
                code_lines.append(f"    }}")
        else:
            # Simple scalar field
            suffix = ""
            if base_type == "float":
                suffix = "f"
            elif base_type == "double":
                suffix = ""  # No suffix for double
                
            code_lines.append(f"    g->properties->{prop['name']} = {initial_value}{suffix};")
    
    return "\n".join(code_lines)

def generate_float_dispatcher(properties):
    """Generate the float property dispatcher function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Get a float property value by property ID")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding field in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement. This provides type-safe")
    c_code.append(" * access to properties without requiring compile-time knowledge of the specific")
    c_code.append(" * property names.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to access")
    c_code.append(" * @param default_value Value to return in case of error")
    c_code.append(" * @return The property value or default_value on error")
    c_code.append(" */")
    c_code.append("float get_generated_float(const galaxy_properties_t *props, property_id_t prop_id, float default_value) {")
    c_code.append("    if (!props) return default_value;")
    c_code.append("    switch (prop_id) {")
    
    # Add case for each float property
    for prop in properties:
        base_type, is_array, _, is_dynamic, _ = parse_type(prop['type'])
        if not is_array and base_type == 'float':
            c_code.append(f"        case PROP_{prop['name']}: return props->{prop['name']};")
    
    c_code.append("        default: return default_value;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_float_setter(properties):
    """Generate the float property setter function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Set a float property value by property ID")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding field in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement. This provides type-safe")
    c_code.append(" * access to properties without requiring compile-time knowledge of the specific")
    c_code.append(" * property names.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to set")
    c_code.append(" * @param value Value to set property to")
    c_code.append(" */")
    c_code.append("void set_generated_float(galaxy_properties_t *props, property_id_t prop_id, float value) {")
    c_code.append("    if (!props) return;")
    c_code.append("    switch (prop_id) {")
    
    # Add case for each float property
    for prop in properties:
        base_type, is_array, _, is_dynamic, _ = parse_type(prop['type'])
        if not is_array and base_type == 'float':
            c_code.append(f"        case PROP_{prop['name']}: props->{prop['name']} = value; break;")
    
    c_code.append("        default: break;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_int32_dispatcher(properties):
    """Generate the int32 property dispatcher function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Get an int32 property value by property ID")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding field in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement. This provides type-safe")
    c_code.append(" * access to properties without requiring compile-time knowledge of the specific")
    c_code.append(" * property names.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to access")
    c_code.append(" * @param default_value Value to return in case of error")
    c_code.append(" * @return The property value or default_value on error")
    c_code.append(" */")
    c_code.append("int32_t get_generated_int32(const galaxy_properties_t *props, property_id_t prop_id, int32_t default_value) {")
    c_code.append("    if (!props) return default_value;")
    c_code.append("    switch (prop_id) {")
    
    # Add case for each int32 property
    for prop in properties:
        base_type, is_array, _, is_dynamic, _ = parse_type(prop['type'])
        if not is_array and (base_type == 'int32_t' or base_type == 'int'):
            c_code.append(f"        case PROP_{prop['name']}: return props->{prop['name']};")
    
    c_code.append("        default: return default_value;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_int32_setter(properties):
    """Generate the int32 property setter function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Set an int32 property value by property ID")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding field in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement. This provides type-safe")
    c_code.append(" * access to properties without requiring compile-time knowledge of the specific")
    c_code.append(" * property names.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to set")
    c_code.append(" * @param value Value to set property to")
    c_code.append(" */")
    c_code.append("void set_generated_int32(galaxy_properties_t *props, property_id_t prop_id, int32_t value) {")
    c_code.append("    if (!props) return;")
    c_code.append("    switch (prop_id) {")
    
    # Add case for each int32 property
    for prop in properties:
        base_type, is_array, _, is_dynamic, _ = parse_type(prop['type'])
        if not is_array and (base_type == 'int32_t' or base_type == 'int'):
            c_code.append(f"        case PROP_{prop['name']}: props->{prop['name']} = value; break;")
    
    c_code.append("        default: break;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_double_dispatcher(properties):
    """Generate the double property dispatcher function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Get a double property value by property ID")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding field in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement. This provides type-safe")
    c_code.append(" * access to properties without requiring compile-time knowledge of the specific")
    c_code.append(" * property names.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to access")
    c_code.append(" * @param default_value Value to return in case of error")
    c_code.append(" * @return The property value or default_value on error")
    c_code.append(" */")
    c_code.append("double get_generated_double(const galaxy_properties_t *props, property_id_t prop_id, double default_value) {")
    c_code.append("    if (!props) return default_value;")
    c_code.append("    switch (prop_id) {")
    
    # Add case for each double property
    for prop in properties:
        base_type, is_array, _, is_dynamic, _ = parse_type(prop['type'])
        if not is_array and base_type == 'double':
            c_code.append(f"        case PROP_{prop['name']}: return props->{prop['name']};")
    
    c_code.append("        default: return default_value;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_double_setter(properties):
    """Generate the double property setter function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Set a double property value by property ID")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding field in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement. This provides type-safe")
    c_code.append(" * access to properties without requiring compile-time knowledge of the specific")
    c_code.append(" * property names.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to set")
    c_code.append(" * @param value Value to set property to")
    c_code.append(" */")
    c_code.append("void set_generated_double(galaxy_properties_t *props, property_id_t prop_id, double value) {")
    c_code.append("    if (!props) return;")
    c_code.append("    switch (prop_id) {")
    
    # Add case for each double property
    for prop in properties:
        base_type, is_array, _, is_dynamic, _ = parse_type(prop['type'])
        if not is_array and base_type == 'double':
            c_code.append(f"        case PROP_{prop['name']}: props->{prop['name']} = value; break;")
    
    c_code.append("        default: break;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_float_array_dispatcher(properties):
    """Generate the float array element property dispatcher function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Get a float array element value by property ID and index")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding array field in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement, then accesses the specified")
    c_code.append(" * array element. This provides type-safe access to array properties without requiring")
    c_code.append(" * compile-time knowledge of the specific property names.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to access")
    c_code.append(" * @param array_idx Index of the array element to access")
    c_code.append(" * @param default_value Value to return in case of error")
    c_code.append(" * @return The array element value or default_value on error")
    c_code.append(" */")
    c_code.append("float get_generated_float_array_element(const galaxy_properties_t *props, property_id_t prop_id, int array_idx, float default_value) {")
    c_code.append("    if (!props) return default_value;")
    c_code.append("    ")
    c_code.append("    // Validate array index")
    c_code.append("    if (array_idx < 0) return default_value;")
    c_code.append("    ")
    c_code.append("    switch (prop_id) {")
    
    # Add case for each float array property
    for prop in properties:
        base_type, is_array, array_dim, is_dynamic, _ = parse_type(prop['type'])
        if is_array and base_type == 'float':
            if is_dynamic:
                # Dynamic array with a size field
                c_code.append(f"        case PROP_{prop['name']}:")
                c_code.append(f"            if (array_idx >= props->{prop['name']}_size || !props->{prop['name']}) return default_value;")
                c_code.append(f"            return props->{prop['name']}[array_idx];")
            else:
                # Fixed size array
                c_code.append(f"        case PROP_{prop['name']}:")
                c_code.append(f"            if (array_idx >= {array_dim}) return default_value;")
                c_code.append(f"            return props->{prop['name']}[array_idx];")
    
    c_code.append("        default: return default_value;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_int32_array_dispatcher(properties):
    """Generate the int32 array element property dispatcher function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Get an int32 array element value by property ID and index")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding array field in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement, then accesses the specified")
    c_code.append(" * array element. This provides type-safe access to array properties without requiring")
    c_code.append(" * compile-time knowledge of the specific property names.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to access")
    c_code.append(" * @param array_idx Index of the array element to access")
    c_code.append(" * @param default_value Value to return in case of error")
    c_code.append(" * @return The array element value or default_value on error")
    c_code.append(" */")
    c_code.append("int32_t get_generated_int32_array_element(const galaxy_properties_t *props, property_id_t prop_id, int array_idx, int32_t default_value) {")
    c_code.append("    if (!props) return default_value;")
    c_code.append("    ")
    c_code.append("    // Validate array index")
    c_code.append("    if (array_idx < 0) return default_value;")
    c_code.append("    ")
    c_code.append("    switch (prop_id) {")
    
    # Add case for each int32 array property
    for prop in properties:
        base_type, is_array, array_dim, is_dynamic, _ = parse_type(prop['type'])
        if is_array and (base_type == 'int32_t' or base_type == 'int'):
            if is_dynamic:
                # Dynamic array with a size field
                c_code.append(f"        case PROP_{prop['name']}:")
                c_code.append(f"            if (array_idx >= props->{prop['name']}_size || !props->{prop['name']}) return default_value;")
                c_code.append(f"            return props->{prop['name']}[array_idx];")
            else:
                # Fixed size array
                c_code.append(f"        case PROP_{prop['name']}:")
                c_code.append(f"            if (array_idx >= {array_dim}) return default_value;")
                c_code.append(f"            return props->{prop['name']}[array_idx];")
    
    c_code.append("        default: return default_value;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_double_array_dispatcher(properties):
    """Generate the double array element property dispatcher function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Get a double array element value by property ID and index")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding array field in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement, then accesses the specified")
    c_code.append(" * array element. This provides type-safe access to array properties without requiring")
    c_code.append(" * compile-time knowledge of the specific property names.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to access")
    c_code.append(" * @param array_idx Index of the array element to access")
    c_code.append(" * @param default_value Value to return in case of error")
    c_code.append(" * @return The array element value or default_value on error")
    c_code.append(" */")
    c_code.append("double get_generated_double_array_element(const galaxy_properties_t *props, property_id_t prop_id, int array_idx, double default_value) {")
    c_code.append("    if (!props) return default_value;")
    c_code.append("    ")
    c_code.append("    // Validate array index")
    c_code.append("    if (array_idx < 0) return default_value;")
    c_code.append("    ")
    c_code.append("    switch (prop_id) {")
    
    # Add case for each double array property
    for prop in properties:
        base_type, is_array, array_dim, is_dynamic, _ = parse_type(prop['type'])
        if is_array and base_type == 'double':
            if is_dynamic:
                # Dynamic array with a size field
                c_code.append(f"        case PROP_{prop['name']}:")
                c_code.append(f"            if (array_idx >= props->{prop['name']}_size || !props->{prop['name']}) return default_value;")
                c_code.append(f"            return props->{prop['name']}[array_idx];")
            else:
                # Fixed size array
                c_code.append(f"        case PROP_{prop['name']}:")
                c_code.append(f"            if (array_idx >= {array_dim}) return default_value;")
                c_code.append(f"            return props->{prop['name']}[array_idx];")
    
    c_code.append("        default: return default_value;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_array_size_dispatcher(properties):
    """Generate the array size dispatcher function."""
    c_code = []
    c_code.append("/**")
    c_code.append(" * @brief Get the size of an array property by property ID")
    c_code.append(" * ")
    c_code.append(" * This function maps from a property_id_t to the corresponding array size in the")
    c_code.append(" * galaxy_properties_t struct using a switch statement. For dynamic arrays, this returns")
    c_code.append(" * the size field value. For fixed arrays, it returns the compile-time array dimension.")
    c_code.append(" * ")
    c_code.append(" * @param props Pointer to the galaxy properties structure")
    c_code.append(" * @param prop_id Property ID to access")
    c_code.append(" * @return The array size or 0 on error/not an array")
    c_code.append(" */")
    c_code.append("int get_generated_array_size(const galaxy_properties_t *props, property_id_t prop_id) {")
    c_code.append("    if (!props) return 0;")
    c_code.append("    ")
    c_code.append("    switch (prop_id) {")
    
    # Add case for each array property
    for prop in properties:
        base_type, is_array, array_dim, is_dynamic, _ = parse_type(prop['type'])
        if is_array:
            if is_dynamic:
                # Dynamic array with a size field
                c_code.append(f"        case PROP_{prop['name']}: return props->{prop['name']}_size;")
            else:
                # Fixed size array
                c_code.append(f"        case PROP_{prop['name']}: return {array_dim};")
    
    c_code.append("        default: return 0;")
    c_code.append("    }")
    c_code.append("}")
    return "\n".join(c_code)

def generate_helper_functions(properties):
    """Generate additional helper functions for the property system"""
    functions = []
    
    # Add size setter functions for dynamic arrays
    dynamic_arrays = [p for p in properties if parse_type(p['type'])[3]]
    for prop in dynamic_arrays:
        base_type = parse_type(prop['type'])[0]
        
        # Start with standard function header and validation
        func_lines = [
            f"/**",
            f" * @brief Set the size of the {prop['name']} dynamic array",
            f" * @param g Galaxy pointer",
            f" * @param size New size for the array",
            f" * @return 0 on success, non-zero on failure",
            f" */",
            f"int galaxy_set_{prop['name']}_size(struct GALAXY *g, int size)",
            "{",
            f"    if (g == NULL || g->properties == NULL) {{",
            f"        LOG_ERROR(\"Cannot set size for NULL galaxy or property pointer\");",
            f"        return -1;",
            f"    }}",
            f"    ",
            f"    if (size < 0) {{",
            f"        LOG_ERROR(\"Cannot set negative size for {prop['name']} array\");",
            f"        return -1;",
            f"    }}",
            f"    ",
            f"    /* Free existing array if present */",
            f"    if (g->properties->{prop['name']} != NULL) {{",
            f"        free(g->properties->{prop['name']});",
            f"        g->properties->{prop['name']} = NULL;",
            f"    }}",
            f"    ",
            f"    /* Set new size */",
            f"    g->properties->{prop['name']}_size = size;",
            f"    ",
            f"    /* Allocate new array if size > 0 */",
            f"    if (size > 0) {{",
            f"        g->properties->{prop['name']} = ({base_type} *)calloc(size, sizeof({base_type}));",
            f"        if (g->properties->{prop['name']} == NULL) {{",
            f"            LOG_ERROR(\"Failed to allocate memory for {prop['name']} array\");",
            f"            g->properties->{prop['name']}_size = 0;",
            f"            return -1;",
            f"        }}"
        ]
        
        # Check for non-zero initial value
        initial_value = prop.get('initial_value')
        if initial_value is not None and str(initial_value) != '0' and str(initial_value) != '0.0':
            func_lines.extend([
                f"        ",
                f"        /* Initialize array with non-zero value {initial_value} */",
                f"        for (int i = 0; i < size; i++) {{",
                f"            g->properties->{prop['name']}[i] = {initial_value};",
                f"        }}"
            ])
        
        # Add function closing
        func_lines.extend([
            f"    }}",
            f"    ",
            f"    return 0;",
            "}"
        ])
        
        # Add function lines to the overall functions list
        functions.extend(func_lines)
    
    return "\n".join(functions)

def generate_resolve_parameter_function():
    """Generate the resolve_parameter_value function"""
    return '''
/**
 * @brief Resolve a parameter name to its integer value
 * @param param_name Name of the parameter (e.g., "simulation.NumSnapOutputs")
 * @param params Pointer to the runtime parameters structure
 * @return Parameter value, or -1 on error
 */
static int resolve_parameter_value(const char *param_name, const struct params *params) {
    if (param_name == NULL || params == NULL) {
        LOG_ERROR("NULL parameter name or params pointer in resolve_parameter_value");
        return -1;
    }
    
    // Add specific parameter lookups here
    if (strcmp(param_name, "simulation.NumSnapOutputs") == 0) {
        // Ensure NumSnapOutputs is valid before returning
        if (params->simulation.NumSnapOutputs <= 0) {
            LOG_ERROR("Invalid value for simulation.NumSnapOutputs: %d", params->simulation.NumSnapOutputs);
            return -1;
        }
        return params->simulation.NumSnapOutputs;
    }
    // Add lookups for other potential size parameters here...
    // Example:
    // else if (strcmp(param_name, "some_other_section.some_size") == 0) {
    //     return params->some_other_section.some_size;
    // }

    LOG_ERROR("Unknown parameter name for dynamic array size: %s", param_name);
    return -1;
}
'''

def generate_header_file(properties, output_dir=""):
    """Generate the property header file"""
    header_filename = "core_properties.h"
    output_path = os.path.join(output_dir, header_filename)
    
    # Generate header components
    include_guard = sanitize_include_guard(header_filename)
    property_id_enum = generate_property_id_enum(properties)
    property_struct_fields = generate_property_struct_fields(properties)
    property_accessor_macros = generate_property_accessor_macros(properties)
    
    # Fill in the template
    header_content = HEADER_TEMPLATE.format(
        header_filename=header_filename,
        include_guard=include_guard,
        timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        property_id_enum=property_id_enum,
        property_struct_fields=property_struct_fields,
        property_accessor_macros=property_accessor_macros
    )
    
    # Write the header file
    with open(output_path, "w") as f:
        f.write(header_content)
    
    print(f"Generated {output_path}")

def generate_galaxy_property_info(properties):
    """Generate GalaxyPropertyInfo array initialization from properties"""
    info_entries = []
    
    for i, prop in enumerate(properties):
        # Get type information
        type_str = prop['type']
        base_type, is_array, array_dim, is_dynamic, size_spec = parse_type(type_str)
        
        # Convert read_only to int value (0=false, 1=true, 2=after_first_set)
        read_only = prop.get('read_only', False)
        read_only_level = 0
        if read_only == True or read_only == "true":
            read_only_level = 1
        elif read_only == "after_first_set":
            read_only_level = 2
        
        # Format the entry
        entry = f"""    {{
        /* name */           "{prop['name']}",
        /* units */          "{prop.get('units', 'dimensionless')}",
        /* description */    "{prop.get('description', '')}",
        /* type_str */       "{type_str}",
        /* is_array */       {str(is_array).lower()},
        /* is_dynamic_array */{str(is_dynamic).lower()},
        /* element_size */   sizeof({base_type}),
        /* array_len */      {array_dim if array_dim and not is_dynamic else 0},
        /* default_value */  NULL,
        /* output_field */   {str(prop.get('output', True)).lower()},
        /* read_only_level */{read_only_level}
    }}"""
        
        # Add comma if not the last entry
        if i < len(properties) - 1:
            entry += ","
            
        info_entries.append(entry)
    
    return "\n".join(info_entries)

def generate_implementation_file(properties, output_dir=""):
    """Generate the property implementation file"""
    impl_filename = "core_properties.c"
    header_filename = "core_properties.h"
    output_path = os.path.join(output_dir, impl_filename)
    
    # Count core properties
    core_property_count = 0
    for prop in properties:
        if prop.get('is_core', False):
            core_property_count += 1
    
    # Generate implementation components
    property_meta_entries = generate_property_meta_entries(properties)
    galaxy_property_info_entries = generate_galaxy_property_info(properties)
    initialize_property_system_code = generate_initialize_code(properties)
    allocate_dynamic_arrays_code = generate_allocate_arrays_code(properties)
    free_dynamic_arrays_code = generate_free_arrays_code(properties)
    copy_fixed_fields_code = generate_copy_fixed_fields_code(properties)
    copy_dynamic_arrays_code = generate_copy_dynamic_arrays_code(properties)
    reset_property_values_code = generate_reset_property_values_code(properties)
    additional_helper_functions = generate_helper_functions(properties)
    resolve_parameter_function = generate_resolve_parameter_function()
    
    # Generate the dispatcher functions
    float_dispatcher = generate_float_dispatcher(properties)
    int32_dispatcher = generate_int32_dispatcher(properties)
    double_dispatcher = generate_double_dispatcher(properties)
    float_array_dispatcher = generate_float_array_dispatcher(properties)
    int32_array_dispatcher = generate_int32_array_dispatcher(properties)
    double_array_dispatcher = generate_double_array_dispatcher(properties)
    array_size_dispatcher = generate_array_size_dispatcher(properties)
    
    # Modify the IMPLEMENTATION_TEMPLATE to add __attribute__((unused)) to params in allocate_galaxy_properties
    modified_template = IMPLEMENTATION_TEMPLATE.replace(
        "int allocate_galaxy_properties(struct GALAXY *g, const struct params *params)",
        "int allocate_galaxy_properties(struct GALAXY *g, const struct params *params __attribute__((unused)))"
    )
    
    # Fill in the template
    impl_content = modified_template.format(
        impl_filename=impl_filename,
        header_filename=header_filename,
        timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
        property_meta_entries=property_meta_entries,
        initialize_property_system_code=initialize_property_system_code,
        allocate_dynamic_arrays_code=allocate_dynamic_arrays_code,
        free_dynamic_arrays_code=free_dynamic_arrays_code,
        copy_fixed_fields_code=copy_fixed_fields_code,
        copy_dynamic_arrays_code=copy_dynamic_arrays_code,
        reset_property_values_code=reset_property_values_code,
        additional_helper_functions=additional_helper_functions,
        resolve_parameter_function=resolve_parameter_function
    )
    
    # Add the dispatcher functions to the implementation file
    impl_content += "\n\n/* Generated property dispatcher functions */\n\n"
    impl_content += float_dispatcher + "\n\n"
    impl_content += int32_dispatcher + "\n\n"
    impl_content += double_dispatcher + "\n\n"
    impl_content += float_array_dispatcher + "\n\n"
    impl_content += int32_array_dispatcher + "\n\n"
    impl_content += double_array_dispatcher + "\n\n"
    impl_content += array_size_dispatcher + "\n\n"
    
    # Add the setter functions to the implementation file
    impl_content += "\n\n/* Generated property setter functions */\n\n"
    impl_content += generate_float_setter(properties) + "\n\n"
    impl_content += generate_int32_setter(properties) + "\n\n"
    impl_content += generate_double_setter(properties) + "\n\n"
    
    # Add the global variable definitions at the top of the implementation file
    impl_content = f"""/* Global variables for property system */
#include <stdint.h>
#include \"core_property_descriptor.h\"
#include \"core_properties.h\"

property_meta_t PROPERTY_META[PROP_COUNT];
const int32_t TotGalaxyProperties = PROP_COUNT;
const int32_t CORE_PROP_COUNT = {core_property_count}; /* Number of core properties, dynamically determined from properties.yaml */
const GalaxyPropertyInfo galaxy_property_info[PROP_COUNT] = {{
{galaxy_property_info_entries}
}};

""" + impl_content
    
    # Write the implementation file
    with open(output_path, "w") as f:
        f.write(impl_content)
    
    print(f"Generated {output_path}")

def load_fetch_numoutputs_placeholder():
    """Create a placeholder function to fetch NumSnapOutputs for dynamic arrays"""
    code = """
/**
 * @brief Fetch NumSnapOutputs parameter for sizing dynamic arrays
 * This is a temporary placeholder for the full parameter system integration
 * @return Number of snapshot outputs or a default value
 */
int fetch_NumSnapOutputs(void) {
    extern struct params Params;  /* From core_allvars.h */
    return Params.simulation.NumSnapOutputs;
}
"""
    return code

def main():
    """Main entry point for the script"""
    # Parse command line arguments for input file
    import argparse
    parser = argparse.ArgumentParser(description='Generate property headers from YAML definition')
    parser.add_argument('--input', default='properties.yaml', help='Input YAML file (default: properties.yaml)')
    args = parser.parse_args()
    
    # Determine file paths
    script_dir = os.path.dirname(os.path.abspath(__file__))
    yaml_file = os.path.join(script_dir, args.input)
    core_dir = os.path.join(script_dir, "core")
    
    # Check if input file exists
    if not os.path.exists(yaml_file):
        print(f"Error: Could not find {args.input} at {yaml_file}")
        sys.exit(1)
    
    try:
        # Load properties from YAML
        with open(yaml_file, "r") as f:
            data = yaml.safe_load(f)
            properties = data.get("properties", [])
        
        if not properties:
            print(f"Error: No properties found in {args.input}")
            sys.exit(1)
        
        # Generate the header and implementation files
        generate_header_file(properties, core_dir)
        generate_implementation_file(properties, core_dir)
        
        # Generate the output transformers file
        generate_transformers_file(properties, core_dir)
        
        print("Property header generation complete!")
        
    except Exception as e:
        print(f"Error generating property headers: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()
